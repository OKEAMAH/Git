#!/bin/sh

# TODO: https://gitlab.com/tezos/tezos/-/issues/6638
#       Currently, we fix e2e testing to Javascript runtime (parse_and_print.js).
#       As the project evolves we may want to support more target environments.
#       This could be solved by --target-language and --target-script-path
#       parameters.

# TODO: https://gitlab.com/tezos/tezos/-/issues/6666
#       The script is generally very verbose. We may want to add logging levels.

set -u

if [ -n "${TRACE:-}" ]; then set -x; fi

usage() {
    cat << EOF
Usage: $0 KSY_DIR HEX_INPUT_DIR

$(basename "$0") is a script used for e2e testing of kaitai struct files.

Arguments:
KSY_DIR                 Directory with kaitai struct files (.ksy files) to be
                        validated.
HEX_INPUT_DIR           Directory with test inputs for .ksy files inside KSY_DIR.
                        It should consist of "valid" and "invalid" sub-directories.

                        For every .ksy file inside KSY_DIR/[encoding].ksy,
                        script expects the following entries:
                        - HEX_INPUT_DIR/valid/[encoding]/*.hex (valid input).
                        - HEX_INPUT_DIR/invvalid/[encoding]/*.hex (invalid input).

The e2e test consist of the following steps:
1. For every kaitai struct specification file (.ksy file), we first
   generate a valid parser in Javascript using "kaitai-struct-compiler".
2. For every autogenerated parser from 1., we test that it succeeds parsing
   corresponding valid binary blobs and fails parsing invalid binary blobs.

DEPENDENCIES:
- We expect "node" and "npm" to be installed and part of the "PATH".
- "kaitai-struct-compiler": E.g. see https://github.com/kaitai-io/kaitai_struct_compiler.
- Kaitai Javascript runtime environment: E.g. run "npm i".
- parse_and_print.js script that should be located in the same directory as
  $(basename "$0"). This script loads autogenerated Javascript parser and tries
  to parse and print corresponding sample inputs.
EOF
    exit 1
}

if [ "${1:-}" = "--help" ] || [ $# != 2 ]; then
    usage
fi

indent_output() {
    num_spaces=$1
    spaces=$(printf ' %.0s' $(seq 1 "$num_spaces"))
    sed "s/^/${spaces}/" >&2
}

log_with_ident () {
    echo "$2" | indent_output "$1"
}

log () {
    echo "$1" >&2
}

# This is needed since we generate parsers inside /tmp, that depend on the local
# installation of `kaitai-struct` module.
current_dir="$(pwd)"
export NODE_PATH="$current_dir/node_modules"
# Test for dependencies
kaitai_struct_package=kaitai-struct@0.10.0
kaitai_struct_module=kaitai-struct
commands="find xxd npm node kaitai-struct-compiler"
if ! npm list kaitai-struct@0.10.0 | grep kaitai-struct@0.10.0 >/dev/null; then
    echo "$kaitai_struct_package (npm package) is missing."
    exit 1
fi
# Parsers are generated inside /tmp directory and require to have access
# to `kaitai-struct` node module. We make explicit check for this scenario here.
if ! (cd /tmp && node -e "require.resolve('$kaitai_struct_module')" >/dev/null 2>&1); then
    echo "\"$kaitai_struct_module\" module is not found."
    exit 1
fi
for cmd in $commands; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Command not found: $cmd"
        exit 1
    fi
done

DIR=$(dirname "$0")
PARSE_AND_PRINT="$DIR/parse_and_print.js"
KSY_DIR="$1"
HEX_INPUT_DIR="$2"

# Create a temporary directory
tmp=$(mktemp -d)

cleanup() {
    rm -rf "${tmp}"
    exit
}

# Register a cleanup.
trap cleanup EXIT INT

parse_hex_input() {
    hex_file=$1
    encoding=$2
    parser=$3
    valid=$4
    input_filename="$(basename "$hex_file" .hex)"
    bin_file=$(mktemp --tmpdir="${tmp}" --suffix ".${encoding}.${input_filename}.bin")
    xxd -r -p <"$hex_file" >"$bin_file"
    if $valid; then
        log "Running validation of $encoding using valid '$input_filename.hex' input."
        log "Parsing and printing should succeed."
    else
        log "Running validation of $encoding using invalid '$input_filename.hex' input."
        log "Parsing and printing should fail. You should see error log below."
    fi
    log "Bin file path: $bin_file"
    log "Hex input for testing ${encoding}'s autogenerated parser: "
    log_with_ident 4 "$(cat "$hex_file")"
    log "Binary input for testing ${encoding}'s autogenerated parser: "
    log_with_ident 4 "$(xxd -b: <"${bin_file}")"
    # To test semantic correctness of autogenerated javascript parser, we load
    # the parser, parse the binary input with it, and print it to console.
    node "$PARSE_AND_PRINT" "$parser" "$bin_file" "$valid"
}

dir_has_hex_files () {
    find "${1}"/*.hex -maxdepth 0 -type f >/dev/null 2>&1
}

validate_kaitai_spec() {
    encoding=$1
    valid_input=$2
    invalid_input=$3
    ksy_file="${KSY_DIR}/${encoding}.ksy"
    # kaitai-struct-compiler gives an auto-generated file a random name.
    # In order to get this filename at runtime, we
    # create a dummy `tmp/*/parser/${encoding}/` dir
    # and get an autogenerated file assuming that this
    # directory contains only one file.
    parser_dir="${tmp}/parsers/${encoding}"
    mkdir -p "$parser_dir"
    kaitai-struct-compiler "$ksy_file" -t javascript --outdir "$parser_dir"
    parser_path="$(find "$parser_dir" -type f | head -n 1)"
    log "ksy file we are testing:"
    log_with_ident 4 "$(cat "$ksy_file")"
    log "Autogenerated parser from ${encoding}'s ksy file:"
    log_with_ident 4 "$(cat "$parser_path")"
    for hex_file in "$valid_input"/*; do
        # We have tested above valid input dir is not empty.
        parse_hex_input "$hex_file" "$encoding" "$parser_path" true
        validation_status=$?
        if [ $validation_status != 0 ]; then
            log "$encoding: Autogenerated parser fails to parse valid binary blob."
            return 1
        fi
    done
    for hex_file in "$invalid_input"/*; do
        if [ ! -f "$hex_file" ] ; then
            # No invalid input files => nothing to test.
            return 0
        fi
        parse_hex_input "$hex_file" "$encoding" "$parser_path" false
        validation_status=$?
        if [ $validation_status != 0 ]; then
            log "$encoding: Autogenerated parser parses invalid(!) binary blob."
            return 1
        fi
    done
}

valid=0
invalid=0
untested=0
total=0
for ksy_file in "$KSY_DIR"/*.ksy; do
    encoding="$(basename "$ksy_file" .ksy)"
    valid_input_dir="${HEX_INPUT_DIR}/valid/${encoding}"
    invalid_input_dir="${HEX_INPUT_DIR}/invalid/${encoding}"
    total=$((total += 1))
    log "Running validation of $ksy_file:"
    if ! dir_has_hex_files "$valid_input_dir" ; then
        log_with_ident 4 "- Aborting validation of \"$encoding\" due to missing valid input files."
        log_with_ident 4 "- To fix this add at least one valid \".hex\" file inside: \"$valid_input_dir\"."
        untested=$((untested + 1))
        continue
    fi
    # Emit warning if no corresponding invalid input files.
    if ! dir_has_hex_files "$invalid_input_dir" ; then
        log_with_ident 4 "- WARNING: \"$encoding\" has no coresponding invalid input files."
        log_with_ident 4 "- To fix this add at least one invalid \".hex\" file inside: \"$invalid_input_dir\"."
    fi
    validation_output=$(validate_kaitai_spec "$encoding" "$valid_input_dir" "$invalid_input_dir" 2>&1)
    validation_status=$?
    if [ $validation_status -eq 0 ]; then
        valid=$((valid + 1))
        log_with_ident 4 "$encoding kaitai spec file is valid."
    else
        log_with_ident 4 "$encoding kaitai spec files is not valid."
        log_with_ident 4 "See the action log:"
        log_with_ident 8 "$validation_output"
        invalid=$((invalid + 1))
    fi
done
cat << EOF
VALIDATION RESULTS:
    - $valid/$total are semantically valid.
    - $invalid/$total are semantically invalid.
    - $untested/$total are not tested due to a missing input files.
EOF

# This command succeeds unless semantically invalid files are found.
# Having untested files is fine for now.
if [ $((valid + untested)) -eq $total ]; then
    exit 0;
else
    exit 1
fi
