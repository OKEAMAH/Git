//****************************************************************************//
//                                                                            //
// SPDX-License-Identifier: MIT                                               //
// Copyright (c) [2023] Serokell <hi@serokell.io>                             //
//                                                                            //
//****************************************************************************//

#![allow(dead_code, unused_imports)]
#![allow(clippy::all)]
#![cfg(not(tarpaulin_include))]

use crate::ast::*;
use crate::parser::{ParserError, ContractScriptEntity, validate_u10};
use crate::lexer::{LexerError, Prim, PrimWithTzt, TztPrim as TzP, Tok};
use crate::typechecker as TC;
use crate::tzt::*;
use PrimWithTzt::*;
use PrimWithTzt as PT;

grammar;

extern {
    type Error = ParserError;
    type Location = usize;

    enum Tok {
        "stack_elt" => Tok::Prim(TztPrim(TzP::Stack_elt)),
        "input" => Tok::Prim(TztPrim(TzP::input)),
        "output" => Tok::Prim(TztPrim(TzP::output)),
        "failed" => Tok::Prim(TztPrim(TzP::Failed)),
        "mutezOverflow" => Tok::Prim(TztPrim(TzP::MutezOverflow)),
        "generalOverflow" => Tok::Prim(TztPrim(TzP::GeneralOverflow)),
        "StaticError" => Tok::Prim(TztPrim(TzP::StaticError)),
        "amount" => Tok::Prim(TztPrim(TzP::amount)),
        number => Tok::Number(<i128>),
        string => Tok::String(<String>),
        ann => Tok::Annotation,
        "parameter" => Tok::Prim(PT::Prim(Prim::parameter)),
        "storage" => Tok::Prim(PT::Prim(Prim::storage)),
        "code" => Tok::Prim(PT::Prim(Prim::code)),
        "int" => Tok::Prim(PT::Prim(Prim::int)),
        "nat" => Tok::Prim(PT::Prim(Prim::nat)),
        "bool" => Tok::Prim(PT::Prim(Prim::bool)),
        "mutez" => Tok::Prim(PT::Prim(Prim::mutez)),
        "string" => Tok::Prim(PT::Prim(Prim::string)),
        "unit" => Tok::Prim(PT::Prim(Prim::unit)),
        "operation" => Tok::Prim(PT::Prim(Prim::operation)),
        "pair" => Tok::Prim(PT::Prim(Prim::pair)),
        "option" => Tok::Prim(PT::Prim(Prim::option)),
        "list" => Tok::Prim(PT::Prim(Prim::list)),
        "map" => Tok::Prim(PT::Prim(Prim::map)),
        "or" => Tok::Prim(PT::Prim(Prim::or)),
        "True" => Tok::Prim(PT::Prim(Prim::True)),
        "False" => Tok::Prim(PT::Prim(Prim::False)),
        "Unit" => Tok::Prim(PT::Prim(Prim::Unit)),
        "None" => Tok::Prim(PT::Prim(Prim::None)),
        "Pair" => Tok::Prim(PT::Prim(Prim::Pair)),
        "Some" => Tok::Prim(PT::Prim(Prim::Some)),
        "Elt" => Tok::Prim(PT::Prim(Prim::Elt)),
        "Left" => Tok::Prim(PT::Prim(Prim::Left)),
        "Right" => Tok::Prim(PT::Prim(Prim::Right)),
        "PUSH" => Tok::Prim(PT::Prim(Prim::PUSH)),
        "INT" => Tok::Prim(PT::Prim(Prim::INT)),
        "GT" => Tok::Prim(PT::Prim(Prim::GT)),
        "LOOP" => Tok::Prim(PT::Prim(Prim::LOOP)),
        "DIP" => Tok::Prim(PT::Prim(Prim::DIP)),
        "ADD" => Tok::Prim(PT::Prim(Prim::ADD)),
        "DROP" => Tok::Prim(PT::Prim(Prim::DROP)),
        "SWAP" => Tok::Prim(PT::Prim(Prim::SWAP)),
        "IF" => Tok::Prim(PT::Prim(Prim::IF)),
        "DUP" => Tok::Prim(PT::Prim(Prim::DUP)),
        "FAILWITH" => Tok::Prim(PT::Prim(Prim::FAILWITH)),
        "UNIT" => Tok::Prim(PT::Prim(Prim::UNIT)),
        "CAR" => Tok::Prim(PT::Prim(Prim::CAR)),
        "CDR" => Tok::Prim(PT::Prim(Prim::CDR)),
        "PAIR" => Tok::Prim(PT::Prim(Prim::PAIR)),
        "IF_NONE" => Tok::Prim(PT::Prim(Prim::IF_NONE)),
        "SOME" => Tok::Prim(PT::Prim(Prim::SOME)),
        "COMPARE" => Tok::Prim(PT::Prim(Prim::COMPARE)),
        "AMOUNT" => Tok::Prim(PT::Prim(Prim::AMOUNT)),
        "NIL" => Tok::Prim(PT::Prim(Prim::NIL)),
        "GET" => Tok::Prim(PT::Prim(Prim::GET)),
        "UPDATE" => Tok::Prim(PT::Prim(Prim::UPDATE)),
        "UNPAIR" => Tok::Prim(PT::Prim(Prim::UNPAIR)),
        "CONS" => Tok::Prim(PT::Prim(Prim::CONS)),
        "IF_CONS" => Tok::Prim(PT::Prim(Prim::IF_CONS)),
        "ITER" => Tok::Prim(PT::Prim(Prim::ITER)),
        "IF_LEFT" => Tok::Prim(PT::Prim(Prim::IF_LEFT)),
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        ";" => Tok::Semi,
        "_" => Tok::Prim(PT::Underscore)
    }
}

u10: u16 = number =>? validate_u10(<>).map_err(Into::into);

anns: () = ann* => ();

atomic_type: Type = {
  "int"  => Type::Int,
  "nat"  => Type::Nat,
  "bool" => Type::Bool,
  "mutez" => Type::Mutez,
  "string" => Type::String,
  "unit" => Type::Unit,
  "operation" => Type::Operation,
}

pair_args: Type = {
    type_expr => <>,
    type_expr pair_args => Type::new_pair(<>)
}

composite_type: Type = {
    "pair"   anns <type_expr> <pair_args> => Type::new_pair(<>),
    "option" anns <type_expr> => Type::new_option(<>),
    "list"   anns <type_expr> => Type::new_list(<>),
    "map"    anns <type_expr> <type_expr> => Type::new_map(<>),
    "or"     anns <type_expr> <type_expr> => Type::new_or(<>),
}

type_expr: Type = {
    <atomic_type> => <>,
    "(" <atomic_type> ann anns ")" => <>,
    "(" <composite_type> ")" => <>,
    "(" <type_expr> ")" => <>,
}

boolean: bool = {
  "True" => true,
  "False" => false,
}

atomic_value: Value = {
  <n:number> => Value::Number(n),
  <b:boolean> => Value::Boolean(b),
  <string> => Value::String(<>),
  "Unit" => Value::Unit,
  "None" => Value::Option(None),
}

pair_val_args: Value = {
  value_expr => <>,
  value_expr pair_val_args => Value::new_pair(<>)
}

composite_value: Value = {
  "Pair" <value_expr> <pair_val_args> => Value::new_pair(<>),
  "Some" <value_expr> => Value::new_option(Some(<>)),
  "Elt" <value_expr> <value_expr> => Value::new_elt(<>),
  "Left" <value_expr> => Value::new_or(Or::Left(<>)),
  "Right" <value_expr> => Value::new_or(Or::Right(<>)),
}

value_expr: Value = {
  atomic_value => <>,
  "(" <value_expr_naked> ")" => <>,
  "{" <value_seq> "}" => Value::Seq(<>),
}

value_expr_naked: Value = {
  composite_value => <>,
  value_expr => <>,
}

value_seq: Vec<Value> = semicolonSepSeq<value_expr_naked>;

use Instruction::*;

#[inline]
atomic_instruction: ParsedInstruction = {
  "ADD" => Add(()),
  "INT" => Int,
  "GT" => Gt,
  "SWAP" => Swap,
  "FAILWITH" => Failwith(()),
  "UNIT" => Unit,
  "CAR" => Car,
  "CDR" => Cdr,
  "PAIR" => Pair,
  "SOME" => ISome,
  "COMPARE" => Compare,
  "AMOUNT" => Instruction::Amount,
  "GET" => Get(()),
  "UPDATE" => Update(()),
  "DROP" => Drop(None),
  "DUP" => Dup(None),
  "UNPAIR" => Unpair,
  "CONS" => Cons,
}

instruction: ParsedInstruction = {
  <atomic_instruction> anns => <>,
  "PUSH" anns <type_expr> <value_expr> => Push((<>)),
  "LOOP" anns <ib: instructionBlock> => Loop(ib),
  "DIP" anns <n:u10?> <ib: instructionBlock> => Dip(n, ib),
  "DROP" anns <u10> => Drop(Some(<>)),
  "IF" anns <t: instructionBlock> <f: instructionBlock> => If(t, f),
  "DUP" anns <u10> => Dup(Some(<>)),
  "IF_NONE" anns <instructionBlock> <instructionBlock> => IfNone(<>),
  "NIL" anns <type_expr> => Nil(<>),
  "IF_CONS" anns <instructionBlock> <instructionBlock> => IfCons(<>),
  "ITER" anns <instructionBlock> => Iter((), <>),
  "IF_LEFT" anns <instructionBlock> <instructionBlock> => IfLeft(<>),
  instructionBlock => Instruction::Seq(<>),
}

instructionSeq = semicolonSepSeq<instruction>;

semicolonSepSeq<T>: Vec<T> = {
  <mut tseq:(<T>";")*><i:T?> => {
    // A sequence of T-followed-by-a-semicolon matched by
    // `(<T>";")*` resulting in `Vec<T>` and bound to `ib`,
    // which can be optionally followed by a single trailing T,
    // matched by `<i:T?>.

    match i {
      Some(t) => {
        tseq.push(t);
        tseq
      },
      None => tseq
    }
  }
}

instructionBlock: ParsedInstructionBlock = {
  "{" <is:instructionSeq> "}" => is,
}

// synonym for consistent type naming
pub InstructionBlock = instructionBlock;

// synonym for consistent type naming
pub Type: Type = type_expr;

code_content: ParsedInstruction = {
  atomic_instruction => <>,
  "(" <instruction> ")" => <>,
  instructionBlock => Instruction::Seq(<>),
}

ContractScriptEntity: ContractScriptEntity = {
  "parameter" <type_expr> => ContractScriptEntity::Parameter(<>),
  "storage" <type_expr> => ContractScriptEntity::Storage(<>),
  "code" <code_content> => ContractScriptEntity::Code(<>),
}

ContractScriptEntitySeq = semicolonSepSeq<ContractScriptEntity>;

pub ContractScript: ContractScript<ParsedStage> = {
  ContractScriptEntitySeq =>? <>.try_into().map_err(Into::into),
  "{" <ContractScript> "}" => <>,
}

// For parsing TZT Tests

use TztEntity::*;
use TztOutput::*;

tztStackElt : (Type, Value) = {
  "stack_elt" <t:type_expr> <v:value_expr> => (t, v)
}

tztStackEltSeq = semicolonSepSeq<tztStackElt>;

tztStack : Vec<(Type, Value)> = {
  "{" <s:tztStackEltSeq> "}" => s
}

mutezAmount : i64 =
  <n:number> =>? i64::try_from(n)
    .map_err(|_| ParserError::LexerError(LexerError::NumericLiteral(n.to_string())).into() );

use ErrorExpectation::*;
use InterpreterErrorExpectation::*;
tztEntity : TztEntity = {
  "code" <ib:instructionBlock> => Code(ib),
  "input" <s:tztStack> => Input(s),
  "output" <s:tztStack> => Output(TztSuccess(s)),
  "output" "(" "failed" <v:value_expr> ")" => Output(TztError(InterpreterError(FailedWith(v)))),
  "output" "(" "mutezOverflow" <a1:mutezAmount> <a2:mutezAmount> ")" => Output(TztError(InterpreterError(MutezOverflow(a1, a2)))),
  "output" "(" "generalOverflow" <a1:number> <a2:number> ")" => Output(TztError(InterpreterError(GeneralOverflow(a1, a2)))),
  "output" "(" "StaticError" <s:string> ")" => Output(TztError(TypecheckerError(Some(s)))),
  "output" "(" "StaticError" "_"  ")" => Output(TztError(TypecheckerError(None))),
  "amount" <m:mutezAmount> => TztEntity::Amount(m)
}

pub tztTestEntities : Vec<TztEntity> = semicolonSepSeq<tztEntity>;
