//****************************************************************************//
//                                                                            //
// MIT License                                                                //
// Copyright (c) 2023 Serokell <hi@serokell.io>                               //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included    //
// in all copies or substantial portions of the Software.                     //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//****************************************************************************//

#![allow(dead_code)]
use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::ast::*;

grammar;

number: i32 = <s:r"([+-]?)[0-9]+"> =>? i32::from_str(s)
  .map_err(|_| ParseError::User { error : "parsing of numeric literal failed." } );

usize: usize = {
  <n:number> =>? usize::try_from(n)
    .map_err(|_| ParseError::User { error : "number is too big." } )
}

type_: Type = {
  "int"  => Type::Int,
  "nat"  => Type::Nat,
  "bool" => Type::Bool,
}

boolean: bool = {
  "True" => true,
  "False" => false,
}

use Value::*;
value: Value = {
  <n:number> => NumberValue(n),
  <b:boolean> => BooleanValue(b)
}

use Instruction::*;
instruction: Instruction = {
  "PUSH" <t:type_> <v:value> => Push(t, v),
  "INT" => Int,
  "GT" => Gt,
  "LOOP" <ib: instructionBlock> => Loop(ib),
  "DIP" <n:usize> <ib: instructionBlock> => DipN(n, ib),
  "DIP" <ib: instructionBlock> => Dip(ib),
  "ADD" => Add,
  "DROP" <n:usize> => DropN(n),
  "DROP" => Drop,
  "SWAP" => Swap,
  "IF" <t: instructionBlock> <f: instructionBlock> => If(t, f),
  "DUP" <n:usize> => DupN(n),
  "DUP" => Dup
}

instructionSeq: Vec<Instruction> = {
  <mut ib:(<instruction>";")*><i:instruction?> => {
    // A sequence of instruction-followed-by-a-semicolon matched by
    // `(<instruction>";")*` resulting in `Vec<instruction>` and bound to `ib`,
    // which can be optionally followed by a single trailing instruction,
    // matched by `<i:instruction?>.

    match i {
      Some(instr) => {
        ib.push(instr);
        ib
      },
      None => {
        ib
      }
    }
  }
}

pub instructionBlock: InstructionBlock = {
  "{" <is:instructionSeq> "}" => is,
}
