//****************************************************************************//
//                                                                            //
// SPDX-License-Identifier: MIT                                               //
// Copyright (c) [2023] Serokell <hi@serokell.io>                             //
//                                                                            //
//****************************************************************************//

#![allow(dead_code)]
use std::str::FromStr;

use crate::ast::*;
use crate::parser::{validate_unescape_string, ParserError};

grammar;

extern {
    type Error = ParserError;
}

match {
  r"(?-u:\s)+" => {}, // more or less same as default, but required to build w/o unicode
  _
}

number: i128 = <s:r"([+-]?)[0-9]+"> =>? i128::from_str(s)
  .map_err(|_| ParserError::NumericLiteral(s.to_owned()).into() );

u10: u16 = <s:r"([+-]?)[0-9]+"> =>? {
    let res = u16::from_str(s)
      .map_err(|_| ParserError::ExpectedU10(s.to_owned()) )?;
    if res >= 1024 {
      return Err(ParserError::ExpectedU10(s.to_owned()).into());
    }
    Ok(res)
  };

pub string: String = <r#""(?:\\.|[^\\"])*""#> =>? validate_unescape_string(<>);

// regex as per https://tezos.gitlab.io/active/michelson.html#syntax
ann: () = r#"@%|@%%|%@|[@:%][_0-9a-zA-Z][_0-9a-zA-Z\.%@]*"# => ();

anns: () = ann* => ();

atomic_type: Type = {
  "int"  => Type::Int,
  "nat"  => Type::Nat,
  "bool" => Type::Bool,
  "mutez" => Type::Mutez,
  "string" => Type::String,
  "unit" => Type::Unit,
  "operation" => Type::Operation,
}

pair_args: Type = {
    type_expr => <>,
    type_expr pair_args => Type::new_pair(<>)
}

composite_type: Type = {
    "pair"   anns <type_expr> <pair_args> => Type::new_pair(<>),
    "option" anns <type_expr> => Type::new_option(<>),
    "list"   anns <type_expr> => Type::new_list(<>),
    "map"    anns <type_expr> <type_expr> => Type::new_map(<>),
}

type_expr: Type = {
    <atomic_type> => <>,
    "(" <atomic_type> ann anns ")" => <>,
    "(" <composite_type> ")" => <>,
    "(" <type_expr> ")" => <>,
}

boolean: bool = {
  "True" => true,
  "False" => false,
}

use Value::*;
atomic_value: Value = {
  <n:number> => NumberValue(n),
  <b:boolean> => BooleanValue(b),
  <string> => StringValue(<>),
  "Unit" => UnitValue,
  "None" => OptionValue(None),
}

pair_val_args: Value = {
  value_expr => <>,
  value_expr pair_val_args => Value::new_pair(<>)
}

composite_value: Value = {
  "Pair" <value_expr> <pair_val_args> => Value::new_pair(<>),
  "Some" <value_expr> => Value::new_option(Some(<>)),
  "Elt" <value_expr> <value_expr> => Value::new_elt(<>),
}

value_expr: Value = {
  atomic_value => <>,
  "(" <value_expr_naked> ")" => <>,
  "{" <value_seq> "}" => Value::Seq(<>),
}

value_expr_naked: Value = {
  composite_value => <>,
  value_expr => <>,
}

value_seq: Vec<Value> = semicolonSepSeq<value_expr_naked>;

use Instruction::*;
instruction: ParsedInstruction = {
  "PUSH" anns <type_expr> <value_expr> => Push((<>)),
  "INT" anns => Int,
  "GT" anns => Gt,
  "LOOP" anns <ib: instructionBlock> => Loop(ib),
  "DIP" anns <n:u10?> <ib: instructionBlock> => Dip(n, ib),
  "ADD" anns => Add(()),
  "DROP" anns <n:u10?> => Drop(n),
  "SWAP" anns => Swap,
  "IF" anns <t: instructionBlock> <f: instructionBlock> => If(t, f),
  "DUP" anns <n:u10?> => Dup(n),
  "FAILWITH" anns => Failwith,
  "UNIT" anns => Unit,
  "CAR" anns => Car,
  "CDR" anns => Cdr,
  "PAIR" anns => Pair,
  "IF_NONE" anns <instructionBlock> <instructionBlock> => IfNone(<>),
  "SOME" anns => ISome,
  "COMPARE" anns => Compare,
  "AMOUNT" anns => Amount,
  "NIL" anns <type_expr> => Nil(<>),
  "GET" anns => Get(()),
  "UPDATE" anns => Update(()),
  instructionBlock => Instruction::Seq(<>),
}

instructionSeq = semicolonSepSeq<instruction>;

semicolonSepSeq<T>: Vec<T> = {
  <mut tseq:(<T>";")*><i:T?> => {
    // A sequence of T-followed-by-a-semicolon matched by
    // `(<T>";")*` resulting in `Vec<T>` and bound to `ib`,
    // which can be optionally followed by a single trailing T,
    // matched by `<i:T?>.

    match i {
      Some(t) => {
        tseq.push(t);
        tseq
      },
      None => tseq
    }
  }
}

pub instructionBlock: ParsedInstructionBlock = {
  "{" <is:instructionSeq> "}" => is,
}

pub Type: Type = type_expr;
