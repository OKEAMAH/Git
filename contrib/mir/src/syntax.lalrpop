//****************************************************************************//
//                                                                            //
// SPDX-License-Identifier: MIT                                               //
// Copyright (c) [2023] Serokell <hi@serokell.io>                             //
//                                                                            //
//****************************************************************************//

#![allow(dead_code, unused_imports)]
#![allow(clippy::all)]
#![cfg(not(tarpaulin_include))]

use crate::ast::*;
use crate::parser::{ParserError, ContractScriptEntity, validate_u10};
use crate::lexer::{Prim, Tok};

grammar;

extern {
    type Error = ParserError;
    type Location = usize;

    enum Tok {
        number => Tok::Number(<i128>),
        string => Tok::String(<String>),
        ann => Tok::Annotation,
        "parameter" => Tok::Prim(Prim::parameter),
        "storage" => Tok::Prim(Prim::storage),
        "code" => Tok::Prim(Prim::code),
        "int" => Tok::Prim(Prim::int),
        "nat" => Tok::Prim(Prim::nat),
        "bool" => Tok::Prim(Prim::bool),
        "mutez" => Tok::Prim(Prim::mutez),
        "string" => Tok::Prim(Prim::string),
        "unit" => Tok::Prim(Prim::unit),
        "operation" => Tok::Prim(Prim::operation),
        "pair" => Tok::Prim(Prim::pair),
        "option" => Tok::Prim(Prim::option),
        "list" => Tok::Prim(Prim::list),
        "map" => Tok::Prim(Prim::map),
        "True" => Tok::Prim(Prim::True),
        "False" => Tok::Prim(Prim::False),
        "Unit" => Tok::Prim(Prim::Unit),
        "None" => Tok::Prim(Prim::None),
        "Pair" => Tok::Prim(Prim::Pair),
        "Some" => Tok::Prim(Prim::Some),
        "Elt" => Tok::Prim(Prim::Elt),
        "PUSH" => Tok::Prim(Prim::PUSH),
        "INT" => Tok::Prim(Prim::INT),
        "GT" => Tok::Prim(Prim::GT),
        "LOOP" => Tok::Prim(Prim::LOOP),
        "DIP" => Tok::Prim(Prim::DIP),
        "ADD" => Tok::Prim(Prim::ADD),
        "DROP" => Tok::Prim(Prim::DROP),
        "SWAP" => Tok::Prim(Prim::SWAP),
        "IF" => Tok::Prim(Prim::IF),
        "DUP" => Tok::Prim(Prim::DUP),
        "FAILWITH" => Tok::Prim(Prim::FAILWITH),
        "UNIT" => Tok::Prim(Prim::UNIT),
        "CAR" => Tok::Prim(Prim::CAR),
        "CDR" => Tok::Prim(Prim::CDR),
        "PAIR" => Tok::Prim(Prim::PAIR),
        "IF_NONE" => Tok::Prim(Prim::IF_NONE),
        "SOME" => Tok::Prim(Prim::SOME),
        "COMPARE" => Tok::Prim(Prim::COMPARE),
        "AMOUNT" => Tok::Prim(Prim::AMOUNT),
        "NIL" => Tok::Prim(Prim::NIL),
        "GET" => Tok::Prim(Prim::GET),
        "UPDATE" => Tok::Prim(Prim::UPDATE),
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        ";" => Tok::Semi,
    }
}

u10: u16 = number =>? validate_u10(<>).map_err(Into::into);

anns: () = ann* => ();

atomic_type: Type = {
  "int"  => Type::Int,
  "nat"  => Type::Nat,
  "bool" => Type::Bool,
  "mutez" => Type::Mutez,
  "string" => Type::String,
  "unit" => Type::Unit,
  "operation" => Type::Operation,
}

pair_args: Type = {
    type_expr => <>,
    type_expr pair_args => Type::new_pair(<>)
}

composite_type: Type = {
    "pair"   anns <type_expr> <pair_args> => Type::new_pair(<>),
    "option" anns <type_expr> => Type::new_option(<>),
    "list"   anns <type_expr> => Type::new_list(<>),
    "map"    anns <type_expr> <type_expr> => Type::new_map(<>),
}

type_expr: Type = {
    <atomic_type> => <>,
    "(" <atomic_type> ann anns ")" => <>,
    "(" <composite_type> ")" => <>,
    "(" <type_expr> ")" => <>,
}

boolean: bool = {
  "True" => true,
  "False" => false,
}

atomic_value: Value = {
  <n:number> => Value::Number(n),
  <b:boolean> => Value::Boolean(b),
  <string> => Value::String(<>),
  "Unit" => Value::Unit,
  "None" => Value::Option(None),
}

pair_val_args: Value = {
  value_expr => <>,
  value_expr pair_val_args => Value::new_pair(<>)
}

composite_value: Value = {
  "Pair" <value_expr> <pair_val_args> => Value::new_pair(<>),
  "Some" <value_expr> => Value::new_option(Some(<>)),
  "Elt" <value_expr> <value_expr> => Value::new_elt(<>),
}

value_expr: Value = {
  atomic_value => <>,
  "(" <value_expr_naked> ")" => <>,
  "{" <value_seq> "}" => Value::Seq(<>),
}

value_expr_naked: Value = {
  composite_value => <>,
  value_expr => <>,
}

value_seq: Vec<Value> = semicolonSepSeq<value_expr_naked>;

use Instruction::*;

#[inline]
atomic_instruction: ParsedInstruction = {
  "ADD" => Add(()),
  "INT" => Int,
  "GT" => Gt,
  "SWAP" => Swap,
  "FAILWITH" => Failwith(()),
  "UNIT" => Unit,
  "CAR" => Car,
  "CDR" => Cdr,
  "PAIR" => Pair,
  "SOME" => ISome,
  "COMPARE" => Compare,
  "AMOUNT" => Amount,
  "GET" => Get(()),
  "UPDATE" => Update(()),
  "DROP" => Drop(None),
  "DUP" => Dup(None),
}

instruction: ParsedInstruction = {
  <atomic_instruction> anns => <>,
  "PUSH" anns <type_expr> <value_expr> => Push((<>)),
  "LOOP" anns <ib: instructionBlock> => Loop(ib),
  "DIP" anns <n:u10?> <ib: instructionBlock> => Dip(n, ib),
  "DROP" anns <u10> => Drop(Some(<>)),
  "IF" anns <t: instructionBlock> <f: instructionBlock> => If(t, f),
  "DUP" anns <u10> => Dup(Some(<>)),
  "IF_NONE" anns <instructionBlock> <instructionBlock> => IfNone(<>),
  "NIL" anns <type_expr> => Nil(<>),
  instructionBlock => Instruction::Seq(<>),
}

instructionSeq = semicolonSepSeq<instruction>;

semicolonSepSeq<T>: Vec<T> = {
  <mut tseq:(<T>";")*><i:T?> => {
    // A sequence of T-followed-by-a-semicolon matched by
    // `(<T>";")*` resulting in `Vec<T>` and bound to `ib`,
    // which can be optionally followed by a single trailing T,
    // matched by `<i:T?>.

    match i {
      Some(t) => {
        tseq.push(t);
        tseq
      },
      None => tseq
    }
  }
}

instructionBlock: ParsedInstructionBlock = {
  "{" <is:instructionSeq> "}" => is,
}

// synonym for consistent type naming
pub InstructionBlock = instructionBlock;

// synonym for consistent type naming
pub Type: Type = type_expr;

code_content: ParsedInstruction = {
  atomic_instruction => <>,
  "(" <instruction> ")" => <>,
  instructionBlock => Instruction::Seq(<>),
}

ContractScriptEntity: ContractScriptEntity = {
  "parameter" <type_expr> => ContractScriptEntity::Parameter(<>),
  "storage" <type_expr> => ContractScriptEntity::Storage(<>),
  "code" <code_content> => ContractScriptEntity::Code(<>),
}

ContractScriptEntitySeq = semicolonSepSeq<ContractScriptEntity>;

pub ContractScript: ContractScript<ParsedStage> = {
  ContractScriptEntitySeq =>? <>.try_into().map_err(Into::into),
  "{" <ContractScript> "}" => <>,
}
