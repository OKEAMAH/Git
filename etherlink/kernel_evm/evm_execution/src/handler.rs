// SPDX-FileCopyrightText: 2022-2024 TriliTech <contact@trili.tech>
// SPDX-FileCopyrightText: 2023 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Handle details of EVM runtime
//!
//! The interface between SputnikVM and the kernel. This includes interface
//! to storage, account balances, block constants, _and transaction state_.

use crate::access_record::AccessRecord;
use crate::account_storage::{
    account_path, AccountStorageError, EthereumAccount, EthereumAccountStorage,
    CODE_HASH_DEFAULT,
};
use crate::transaction::TransactionContext;
use crate::ArithmeticErrorKind::FeeOverflow;
use crate::EthereumError;
use crate::PrecompileSet;
use crate::{storage, tick_model_opcodes};
use alloc::borrow::Cow;
use alloc::rc::Rc;
use core::convert::Infallible;
use evm::executor::stack::Log;
use evm::gasometer::{GasCost, Gasometer, MemoryCost};
use evm::{
    Capture, Config, Context, CreateScheme, ExitError, ExitFatal, ExitReason, ExitRevert,
    ExitSucceed, Handler, Opcode, Stack, Transfer,
};
use host::runtime::Runtime;
use primitive_types::{H160, H256, U256};
use sha3::{Digest, Keccak256};
use std::cmp::min;
use std::collections::BTreeSet;
use std::fmt::Debug;
use std::str::FromStr;
use tezos_ethereum::block::BlockConstants;
use tezos_ethereum::withdrawal::Withdrawal;
use tezos_evm_logging::{log, Level::*};

/// Maximum allowed code size as specified by EIP-170
const MAX_CODE_SIZE: usize = 0x6000;

/// Outcome of making the [EvmHandler] run an Ethereum transaction
///
/// Be it contract -call, -create or simple transfer, the handler will update the world
/// state in durable storage _and_ produce a summary of the outcome that will be needed
/// for creating a transaction receipt.
#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// How much gas was used for processing an entire transaction.
    pub gas_used: u64,
    /// Whether the transaction succeeded or not.
    ///  - In case of transfer-, whether the funds were transferred
    ///  - In case of call-, whether toplevel call returned or stopped (success), or
    ///    something else (revert, invalid code, etc. are non-successes).
    ///  - In case of create-, whethere a new contract was created or not.
    pub is_success: bool,
    /// The sputnik reason for ending execution. In case of transfers, this is made up
    /// (sputnik Doesn't execute those - we do).
    pub reason: ExitReason,
    /// In case of create- transactions, this field contains address of the new contract
    pub new_address: Option<H160>,
    /// Logs generated by the transaction.
    pub logs: Vec<Log>,
    /// Result of the execution
    pub result: Option<Vec<u8>>,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
    /// Number of estimated ticks used at the end of the contract call
    pub estimated_ticks_used: u64,
}

/// The result of calling a contract as expected by the SputnikVM EVM implementation.
/// First part of the tuple tells Sputnik how the execution went (success or failure
/// and in what way). Second part tells Sputnik the return data if any.
type CallOutcome = (ExitReason, Vec<u8>);

/// The result of creating a contract as expected by the SputnikVM EVM implementation.
/// First part of the triple is the execution outcome - same as for normal contract
/// execution. Second part is the address of the newly created contract, if one was
/// created. Last part is the return value, which is required by Sputnik, but it is
/// always an empty vector when this type is used for create outcome.
///
/// Beware that this type is sometimes used as outcome of a _call_. This is simply to
/// be able to use the `end_xxx_transaction` functions for both contract -create and
/// -call. In this case, the last element of the triple can be non-empty, and the
/// address will be `None`.
type CreateOutcome = (ExitReason, Option<H160>, Vec<u8>);

/// Wrap ethereum errors in the SputnikVM errors
///
/// This function wraps critical errors that indicate something is wrong
/// with the kernel or rollup node into errors that can be passed on to
/// SputnikVM execution. This is needed if an error occurs in a callback
/// called by SputnikVM.
fn ethereum_error_to_exit_reason(exit_reason: &EthereumError) -> ExitReason {
    ExitReason::Fatal(ExitFatal::Other(Cow::from(format!("{:?}", exit_reason))))
}

pub enum TransferExitReason {
    Returned,
    OutOfFund,
}

/// Data related to the current transaction layer
struct TransactionLayerData<'config> {
    /// Gasometer for the current transaction layer. If this value is
    /// `None`, then the current transaction has no gas limit and no
    /// gas accounting.
    pub gasometer: Option<Gasometer<'config>>,
    /// Whether the current transaction is static or not, ie, if the
    /// transaction is allowed to update durable storage.
    pub is_static: bool,
    /// The log records gathered in this layer of transactions and any
    /// committed sub layers.
    pub logs: Vec<Log>,
    /// The addresses of contracts that have been deleted as part of
    /// the current transaction.
    pub deleted_contracts: BTreeSet<H160>,
    /// Any withdrawals generated by the current transaction level and
    /// successful sub-levels.
    pub withdrawals: Vec<Withdrawal>,
    /// Keep track of accessed adresses and storages indices.
    /// See EIP-2929 and YP section 6.1
    pub accessed_storage_keys: AccessRecord,
}

impl<'config> TransactionLayerData<'config> {
    /// Create the data associated with one layer of transactions -
    /// one Ethereum transaction context. It initially has no log
    /// records. If the gas limit is `None`, then there will be no
    /// accounting for gas usage throughout the transaction, ie, there
    /// will be no gasometer.
    pub fn new(
        is_static: bool,
        gas_limit: Option<u64>,
        config: &'config Config,
        accessed_storage_keys: AccessRecord,
    ) -> Self {
        TransactionLayerData {
            gasometer: gas_limit.map(|gl| Gasometer::new(gl, config)),
            is_static,
            logs: vec![],
            deleted_contracts: BTreeSet::new(),
            withdrawals: vec![],
            accessed_storage_keys,
        }
    }
}

#[cfg(feature = "benchmark")]
mod benchmarks {

    use super::*;

    /// These values encodes the result of an evaluation step of the virtual
    /// machine. They can be used to filter some data that can be seen as non
    /// conclusive or irrelevant for the ticks model, or simply for data
    /// analysis.
    const STEP_CONTINUE: u8 = 0;
    const SUCCEED_STOP: u8 = 1;
    const SUCCEED_RETURN: u8 = 2;
    const SUCCEED_SUICIDE: u8 = 3;
    const EXIT_ERROR: u8 = 4;
    const EXIT_REVERT: u8 = 5;
    const EXIT_FATAL: u8 = 6;
    const TRAP: u8 = 7;

    #[inline(always)]
    fn step_exit_reason<T>(capture: &Result<(), Capture<ExitReason, T>>) -> u8 {
        match capture {
            Ok(()) => STEP_CONTINUE,
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Stopped))) => SUCCEED_STOP,
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Returned))) => {
                SUCCEED_RETURN
            }
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Suicided))) => {
                SUCCEED_SUICIDE
            }
            Err(Capture::Exit(ExitReason::Error(_))) => EXIT_ERROR,
            Err(Capture::Exit(ExitReason::Revert(_))) => EXIT_REVERT,
            Err(Capture::Exit(ExitReason::Fatal(_))) => EXIT_FATAL,
            Err(Capture::Trap(_)) => TRAP,
        }
    }

    // About the two `static mut` below and their usage
    //
    // Low key optimisation to avoid the formatting: we know that the data are
    // always 1 byte for the opcode, 8 bytes pour the gas (u64), 1 byte for the
    // step exit reason. The messages are preallocated and updated with the
    // correct values each time they are called. It avoid using the formatting.
    // The overhead of formatting is significative.

    // The start section for the opcodes expects a single byte which is the
    // current opcode.
    static mut START_OPCODE_SECTION_MSG: [u8; 35] =
        *b"__wasm_debugger__::start_section(\0)";

    // The start section for the precompiles expects the address of the
    // contract (20 bytes) and the size of the data (4 bytes).
    static mut START_PRECOMPILE_SECTION_MSG: [u8; 58] =
        *b"__wasm_debugger__::start_section(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)";

    #[inline(always)]
    pub fn start_opcode_section<Host: Runtime>(host: &mut Host, opcode: &Opcode) {
        unsafe {
            START_OPCODE_SECTION_MSG[33] = opcode.as_u8();
            host.write_debug(core::str::from_utf8_unchecked(&START_OPCODE_SECTION_MSG));
        }
    }

    #[inline(always)]
    pub fn start_precompile_section<Host: Runtime>(
        host: &mut Host,
        address: H160,
        input: &Vec<u8>,
    ) {
        unsafe {
            START_PRECOMPILE_SECTION_MSG[33..53].copy_from_slice(address.as_bytes());
            START_PRECOMPILE_SECTION_MSG[53..57]
                .copy_from_slice(&input.len().to_be_bytes());
            host.write_debug(core::str::from_utf8_unchecked(
                &START_PRECOMPILE_SECTION_MSG,
            ));
        }
    }

    // The value of the ending sections are:
    // - 8 bytes for the gas, in little endian
    // - 1 byte that describes the continuation of the evaluation: it either
    //   continues to the next opcode (`STEP_CONTINUE`) or stops for a given
    //   reason, this reason being encoded in a byte. These values are described
    //   at the beginning of the `benchmarks` module.
    static mut END_OPCODE_SECTION_MSG: [u8; 41] =
        *b"__wasm_debugger__::end_section(\0\0\0\0\0\0\0\0\0)";

    static mut END_PRECOMPILE_SECTION_MSG: [u8; 32] =
        *b"__wasm_debugger__::end_section()";

    #[inline(always)]
    pub fn end_opcode_section<Host: Runtime, T>(
        host: &mut Host,
        gas: u64,
        step_result: &Result<(), Capture<ExitReason, T>>,
    ) {
        unsafe {
            END_OPCODE_SECTION_MSG[31..39].copy_from_slice(&gas.to_le_bytes());
            END_OPCODE_SECTION_MSG[39] = step_exit_reason(step_result);
            host.write_debug(core::str::from_utf8_unchecked(&END_OPCODE_SECTION_MSG));
        }
    }

    #[inline(always)]
    pub fn end_precompile_section<Host: Runtime>(host: &mut Host) {
        unsafe {
            host.write_debug(core::str::from_utf8_unchecked(&END_PRECOMPILE_SECTION_MSG));
        }
    }
}

pub fn create_address_legacy(caller: &H160, nonce: &U256) -> H160 {
    let mut stream = rlp::RlpStream::new_list(2);
    stream.append(caller);
    stream.append(nonce);
    H256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()
}

/// The implementation of the SputnikVM [Handler] trait
pub struct EvmHandler<'a, Host: Runtime> {
    /// The host
    host: &'a mut Host,
    /// The ethereum accounts storage
    evm_account_storage: &'a mut EthereumAccountStorage,
    /// The original caller initiating the toplevel transaction
    origin: H160,
    /// The constants for the current block
    pub block: &'a BlockConstants,
    /// The precompiled functions
    precompiles: &'a dyn PrecompileSet<Host>,
    /// The configuration, eg, London or Frontier for execution
    config: &'a Config,
    /// The contexts associated with transaction(s) currently in
    /// progress
    transaction_data: Vec<TransactionLayerData<'a>>,
    /// Estimated number of ticks remaining for the current run
    pub ticks_allocated: u64,
    /// Estimated ticks spent for the execution of the current transaction,
    /// according to the ticks per gas per opcode model
    pub estimated_ticks_used: u64,
    /// The effective gas price of the current transaction
    effective_gas_price: U256,
    /// Whether warm/cold storage and address access is enabled
    /// If not, all access are considered cold
    pub enable_warm_access: bool,
}

impl<'a, Host: Runtime> EvmHandler<'a, Host> {
    /// Create a new handler to suit a new, initial EVM call context
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        host: &'a mut Host,
        evm_account_storage: &'a mut EthereumAccountStorage,
        origin: H160,
        block: &'a BlockConstants,
        config: &'a Config,
        precompiles: &'a dyn PrecompileSet<Host>,
        ticks_allocated: u64,
        effective_gas_price: U256,
    ) -> Self {
        Self {
            host,
            evm_account_storage,
            origin,
            block,
            config,
            precompiles,
            transaction_data: vec![],
            ticks_allocated,
            estimated_ticks_used: 0,
            effective_gas_price,
            /// Set thenable_warm_access to true before running evaluation test
            enable_warm_access: false,
        }
    }

    /// Get the total amount of gas used for the duration of the current
    /// transaction.
    pub fn gas_used(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| {
                layer
                    .gasometer
                    .as_ref()
                    .map(|g| g.total_used_gas())
                    .unwrap_or(0_u64)
            })
            .unwrap_or(0_u64)
    }

    /// Get the amount of gas still available for the current transaction.
    fn gas_remaining(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| layer.gasometer.as_ref().map(|g| g.gas()).unwrap_or(0_u64))
            .unwrap_or(0_u64)
    }

    /// Record the cost of a static-cost opcode
    pub fn record_cost(&mut self, cost: u64) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_cost(cost))
            .unwrap_or(Ok(()))
    }

    /// Record code deposit. Pay per byte for a CREATE operation
    pub fn record_deposit(&mut self, len: usize) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_deposit(len))
            .unwrap_or(Ok(()))
    }

    /// Record the cost of a dynamic-cost opcode
    fn record_dynamic_cost(
        &mut self,
        cost: GasCost,
        memory_cost: Option<MemoryCost>,
    ) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_dynamic_cost(cost, memory_cost))
            .unwrap_or(Ok(()))
    }

    /// Record the refund of a contract call. This differs from a storage
    /// operation refund in that the refunded gas can be used again by the
    /// same transaction. Function name reflects the SputnikVM name used to
    /// implement this functionality.
    fn record_stipend(&mut self, stipend: u64) -> Result<(), EthereumError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(EthereumError::InconsistentTransactionStack(self.transaction_data.len(), false, false))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_stipend(stipend))
            .unwrap_or(Ok(()))
            .map_err(|_| {
                EthereumError::InconsistentState(Cow::from(
                    "Recording a stipend returned an error",
                ))
            })
    }

    /// Mark a location in durable storage as _hot_ for the purpose of calculating
    /// cost of SSTORE and SLOAD. Return type chosen for compatibility with the
    /// SputnikVM functions that need to call this function.
    fn mark_storage_as_hot(
        &mut self,
        address: H160,
        index: H256,
    ) -> Result<(), ExitError> {
        if !self.enable_warm_access {
            return Ok(());
        }
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Invalid transaction data stack for mark_storage_as_hot")))
        };

        layer.accessed_storage_keys.insert_storage(address, index);

        Ok(())
    }

    /// Mark an address as _hot_ for the purpose of calculating
    /// cost of SSTORE and SLOAD. Return type chosen for compatibility with the
    /// SputnikVM functions that need to call this function.
    fn mark_address_as_hot(&mut self, address: H160) -> Result<(), ExitError> {
        if !self.enable_warm_access {
            return Ok(());
        }
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Invalid transaction data stack for mark_address_as_hot")))
        };

        layer.accessed_storage_keys.insert_address(address);

        Ok(())
    }

    /// Check if some location in durable storage is hot
    fn is_storage_hot(&self, address: H160, index: H256) -> Result<bool, ExitError> {
        let Some(layer) = self.transaction_data.last() else {
            return Err(ExitError::Other(Cow::from("Invalid transaction data stack for is_storage_hot")))
        };

        Ok(layer.accessed_storage_keys.contains_storage(address, index))
    }

    /// Check if address is hot
    fn is_address_hot(&self, address: H160) -> Result<bool, ExitError> {
        let Some(layer) = self.transaction_data.last() else {
                return Err(ExitError::Other(Cow::from("Invalid transaction data stack for is_address_hot")))
            };

        Ok(layer.accessed_storage_keys.contains_address(address))
    }

    /// Check if an address has either a nonzero nonce, or a nonzero code length, i.e., if the address exists.
    fn is_colliding(&mut self, address: H160) -> Result<bool, EthereumError> {
        let Some(account) = self.get_account(address) else {
            return Ok(false);
        };

        let has_code = account
            .code_size(self.borrow_host())
            .map(|s| s != U256::zero())?;
        let non_zero_nonce = account
            .nonce(self.borrow_host())
            .map(|s| s != U256::zero())?;

        Ok(has_code || non_zero_nonce)
    }

    /// Returns true if there is a static transaction in progress, otherwise
    /// return false.
    fn is_static(&self) -> bool {
        self.transaction_data
            .last()
            .map(|data| data.is_static)
            .unwrap_or(false)
    }

    /// Record the base fee part of the transaction cost. We need the SputnikVM
    /// error code in case this goes wrong, so that's what we return.
    fn record_base_gas_cost(
        &mut self,
        is_create: bool,
        data: &[u8],
    ) -> Result<(), ExitError> {
        let base_cost = if is_create {
            self.config.gas_transaction_create
        } else {
            self.config.gas_transaction_call
        };

        let data_cost: u64 = data
            .iter()
            .map(|datum| {
                if *datum == 0_u8 {
                    self.config.gas_transaction_zero_data
                } else {
                    self.config.gas_transaction_non_zero_data
                }
            })
            .sum();

        self.record_cost(base_cost + data_cost)
    }

    /// Add withdrawals to the current transaction layer
    fn add_withdrawals(
        &mut self,
        withdrawals: &mut Vec<Withdrawal>,
    ) -> Result<(), EthereumError> {
        match self.transaction_data.last_mut() {
            Some(layer) => {
                layer.withdrawals.try_reserve_exact(withdrawals.len())?;
                layer.withdrawals.append(withdrawals);

                Ok(())
            }
            None => Err(EthereumError::InconsistentTransactionStack(0, false, false)),
        }
    }

    /// Have the caller account pay for gas. Returns `Ok(true)` if the payment
    /// went through; returns `Ok(false)` if `caller` doesn't have the funds.
    /// Return `Err(...)` in case something is at fault with durable storage or
    /// runtime.
    pub fn pre_pay_transactions(
        &mut self,
        caller: H160,
        gas_limit: Option<u64>,
        effective_gas_price: U256,
    ) -> Result<bool, EthereumError> {
        let Some(gas_limit) = gas_limit else { return Ok(true) };

        let amount = U256::from(gas_limit)
            .checked_mul(effective_gas_price)
            .ok_or(EthereumError::ArithmeticError(FeeOverflow))?;

        log!(
            self.host,
            Debug,
            "{caller:?} pays {amount:?} for transaction"
        );

        self.get_or_create_account(caller)?
            .balance_remove(self.host, amount)
            .map_err(EthereumError::from)
    }

    /// Repay unused gas
    pub fn repay_gas(
        &mut self,
        caller: H160,
        unused_gas: Option<u64>,
        effective_gas_price: U256,
    ) -> Result<(), EthereumError> {
        let Some(unused_gas) = unused_gas else { return Ok(()) };

        let amount = U256::from(unused_gas)
            .checked_mul(effective_gas_price)
            .ok_or(EthereumError::ArithmeticError(FeeOverflow))?;

        log!(
            self.host,
            Debug,
            "{caller:?} refunded {amount:?} for transaction"
        );

        self.get_or_create_account(caller)?
            .balance_add(self.host, amount)
            .map_err(EthereumError::from)
    }

    /// Account for the estimated ticks spent during the execution of the given opcode
    pub fn account_for_ticks(
        &mut self,
        opcode: &Opcode,
        gas: u64,
    ) -> Result<(), EthereumError> {
        self.estimated_ticks_used += tick_model_opcodes::ticks(opcode, gas);
        if self.estimated_ticks_used > self.ticks_allocated {
            Err(EthereumError::OutOfTicks)
        } else {
            Ok(())
        }
    }

    /// Execute a SputnikVM run with this handler
    ///
    /// Never inlined when the kernel is compiled for benchmarks, to ensure the
    /// function is visible in the profiling results.
    #[cfg_attr(feature = "benchmark", inline(never))]
    fn execute(
        &mut self,
        runtime: &mut evm::Runtime,
    ) -> Result<ExitReason, EthereumError> {
        loop {
            // This decomposition allows both benchmarking the ticks per gas
            // consumption of opcode and implement the tick model at the opcode
            // level. At the end of each step if the kernel takes more than the
            // allocated ticks the transaction is marked as failed.
            let opcode = runtime.machine().inspect().map(|p| p.0);

            #[cfg(feature = "benchmark")]
            if let Some(opcode) = opcode {
                benchmarks::start_opcode_section(self.host, &opcode);
            }

            // For now, these variables capturing the gas one will be marked
            // unused without benchmarking, but they will be used during the
            // tick accounting.
            #[cfg_attr(not(feature = "benchmark"), allow(unused_variables))]
            let gas_before = self.gas_used();

            let step_result = runtime.step(self);

            #[cfg_attr(not(feature = "benchmark"), allow(unused_variables))]
            let gas_after = self.gas_used();

            if let Some(opcode) = opcode {
                let gas = gas_after - gas_before;
                self.account_for_ticks(&opcode, gas)?;
                #[cfg(feature = "benchmark")]
                benchmarks::end_opcode_section(self.host, gas, &step_result);
            };

            match step_result {
                Ok(()) => (),
                Err(Capture::Exit(reason)) => return Ok(reason),
                Err(Capture::Trap(_)) => return Err(EthereumError::InternalTrapError),
            }
        }
    }

    fn create_address(&mut self, scheme: CreateScheme) -> H160 {
        match scheme {
            CreateScheme::Create2 {
                caller,
                code_hash,
                salt,
            } => {
                let mut hasher = Keccak256::new();
                hasher.update([0xff]);
                hasher.update(caller);
                hasher.update(salt);
                hasher.update(code_hash);
                H256::from_slice(hasher.finalize().as_slice()).into()
            }
            CreateScheme::Legacy { caller } => {
                let nonce = self.get_nonce(caller);
                create_address_legacy(&caller, &nonce)
            }
            CreateScheme::Fixed(address) => address,
        }
    }

    /// Execute a transfer between two accounts
    ///
    /// In case the transfer succeeds, the function returns
    /// `Ok(ExitReason::Succeed(ExitSucceed::Returned))`. In case the
    /// transaction fails, but execution doesn't encounter non-contract or
    /// -account errors, it returns `Ok(ExitReason::Error(err))`, where `err`
    /// indicates what went wrong (insufficient balance, etc.). In case of
    /// critical errors in the rollup node or kernel, an `Err(err)` is returned,
    /// where `err` indicates what went wrong, eg, a storage error.
    fn execute_transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
    ) -> Result<TransferExitReason, EthereumError> {
        log!(
            self.host,
            Debug,
            "Executing a transfer from {} to {} of {}",
            from,
            to,
            value
        );

        if value == U256::zero() {
            // Nothing to transfer so succeeds by default
            Ok(TransferExitReason::Returned)
        } else if let Some(mut from_account) = self.get_account(from) {
            let mut to_account = self.get_or_create_account(to)?;

            if from_account.balance_remove(self.host, value)? {
                to_account
                    .balance_add(self.host, value)
                    .map_err(EthereumError::from)?;
                Ok(TransferExitReason::Returned)
            } else {
                log!(
                    self.host,
                    Debug,
                    "Failed transfer for create due to insufficient funds, value: {:?}, from: {:?}, to: {:?}",
                    value,
                    from_account,
                    to
                );

                Ok(TransferExitReason::OutOfFund)
            }
        } else {
            log!(self.host, Debug, "'from' account {:?} is empty", from);
            // Accounts of zero balance by default, so this must be
            // an underflow.
            Ok(TransferExitReason::OutOfFund)
        }
    }

    fn end_create(
        &mut self,
        runtime: evm::Runtime,
        sub_context_result: Result<ExitReason, EthereumError>,
        address: H160,
    ) -> Result<CreateOutcome, EthereumError> {
        match sub_context_result {
            Ok(sub_context_result @ ExitReason::Succeed(ExitSucceed::Suicided)) => {
                Ok((sub_context_result, Some(address), vec![]))
            }
            Ok(sub_context_result @ ExitReason::Succeed(_)) => {
                let code_out = runtime.machine().return_value();

                if code_out.first() == Some(&0xef) {
                    // EIP-3541: see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3541.md
                    return Ok((
                        ExitReason::Error(ExitError::InvalidCode(Opcode(0xef))),
                        None,
                        vec![],
                    ));
                }

                if code_out.len() > MAX_CODE_SIZE {
                    // EIP-170: see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md
                    return Ok((
                        ExitReason::Error(ExitError::CreateContractLimit),
                        None,
                        vec![],
                    ));
                }

                if let Err(err) = self.record_deposit(code_out.len()) {
                    return Ok((ExitReason::Error(err), None, vec![]));
                }

                self.set_contract_code(address, code_out)?;
                // EIP-161: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md
                // A created smart contract nonce must start at 1.
                self.increment_nonce(address)?;

                Ok((sub_context_result, Some(address), vec![]))
            }
            Ok(sub_context_result @ ExitReason::Revert(_)) => {
                // EIP-140: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md
                // In case of a REVERT in a context of a CREATE, CREATE2, the error message
                // is available in the returndata buffer
                Ok((sub_context_result, None, runtime.machine().return_value()))
            }
            // Since the sub context failed, return address 0 (`None` in our case) (https://www.evm.codes/#f0?fork=shanghai)
            Ok(sub_context_result @ ExitReason::Error(_)) => {
                Ok((sub_context_result, None, vec![]))
            }
            Ok(sub_context_result @ ExitReason::Fatal(_)) => {
                Ok((sub_context_result, None, vec![]))
            }
            Err(err) => Err(err),
        }
    }

    /// Create a contract
    ///
    /// Performs the actual contract creation for both transactions initiated
    /// by external accounts and contract creation initiated through contract
    /// execution.
    ///
    /// In the specific case where this function is called via the CREATE opcode,
    /// it needs to bump the nonce. If it's a transaction initated by external
    /// accounts, the nonce must be bumped by the caller.
    fn execute_create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        initial_code: Vec<u8>,
        create_opcode: bool,
    ) -> Result<CreateOutcome, EthereumError> {
        let address = self.create_address(scheme);

        if let Err(_) = self.mark_address_as_hot(address) {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark callee address as hot",
            )));
        }

        if self.deleted(address) && create_opcode {
            if let CreateScheme::Create2 { .. } = scheme {
                // The contract has been deleted, so the address is empty.
                // We are trying to re-create the same contract that was deleted at
                // the same transaction level: this is not allowed.
                // TODO/NB: https://gitlab.com/tezos/tezos/-/issues/6783
                // This behaviour is appropriate to <=Shanghai configuration.
                // In the upcoming Cancun fork, the semantic of this behaviour will change.
                self.increment_nonce(caller)?;
                return Ok((
                    ExitReason::Succeed(ExitSucceed::Stopped),
                    Some(H160::zero()), // see: https://www.evm.codes/#f5?fork=shanghai
                    vec![],
                ));
            }
        }

        log!(self.host, Debug, "Executing a contract create");

        if self.evm_account_storage.stack_depth() >= self.config.stack_limit {
            return Ok((
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::CallTooDeep)),
                None,
                vec![],
            ));
        }

        let context = Context {
            address,
            caller,
            apparent_value: value,
        };

        // TODO: https://gitlab.com/tezos/tezos/-/issues/6716
        // Create collision and failed transfers should use up all the gas
        if self.is_colliding(address)? {
            log!(
                self.host,
                Debug,
                "Failed to create contract at {:?}. Address is non-empty",
                address
            );
            return Ok((ExitReason::Error(ExitError::CreateCollision), None, vec![]));
        }

        match self.execute_transfer(caller, address, value)? {
            TransferExitReason::OutOfFund => {
                return Ok((ExitReason::Error(ExitError::OutOfFund), None, vec![]))
            }
            TransferExitReason::Returned => (), // Otherwise result is ok and we do nothing and continue
        }

        if create_opcode {
            self.increment_nonce(caller)?
        };

        let mut runtime = evm::Runtime::new(
            Rc::new(initial_code),
            Rc::new(Vec::new()),
            context,
            self.config.stack_limit,
            self.config.memory_limit,
        );

        let result = self.execute(&mut runtime);

        self.end_create(runtime, result, address)
    }

    /// Call a contract
    ///
    /// Perform the actual contract execution - works both for executing an
    /// Ethereum transaction as initiated by an external account or as aresult
    /// of any of the -CALL instructions.
    ///
    /// The outcome is encoded as a SputnikVM _Create_ outcome for easy transaction
    /// handling. The new address "field" in the triple is always `None`.
    #[allow(clippy::too_many_arguments)]
    fn execute_call(
        &mut self,
        address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        transaction_context: TransactionContext,
    ) -> Result<CreateOutcome, EthereumError> {
        log!(
            self.host,
            Debug,
            "Executing contract call on contract {} at depth: {}",
            address,
            self.evm_account_storage.stack_depth()
        );

        if let Err(_) = self.mark_address_as_hot(address) {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark callee address as hot",
            )));
        }

        if self.evm_account_storage.stack_depth() > self.config.stack_limit {
            log!(self.host, Debug, "Execution beyond the call limit of 1024");

            return Ok((
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::CallTooDeep)),
                None,
                vec![],
            ));
        }

        // TODO: check gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5120

        // TODO: add transfer to gas (if it is there)
        // issue: https://gitlab.com/tezos/tezos/-/issues/5121

        if let Some(ref transfer) = transfer {
            match self.execute_transfer(
                transaction_context.context.caller,
                address,
                transfer.value,
            )? {
                TransferExitReason::OutOfFund => {
                    return Ok((ExitReason::Error(ExitError::OutOfFund), None, vec![]))
                }
                TransferExitReason::Returned => (), // Otherwise result is ok and we do nothing and continue
            }
        }
        #[cfg(feature = "benchmark")]
        benchmarks::start_precompile_section(self.host, address, &input);

        let precompile_execution_result = self.precompiles.execute(
            self,
            address,
            &input,
            &transaction_context.context,
            self.is_static(),
            transfer,
        );

        #[cfg(feature = "benchmark")]
        benchmarks::end_precompile_section(self.host);

        if let Some(precompile_result) = precompile_execution_result {
            match precompile_result {
                Ok(mut outcome) => {
                    self.add_withdrawals(&mut outcome.withdrawals)?;
                    self.estimated_ticks_used += outcome.estimated_ticks;
                    Ok((outcome.exit_status, None, outcome.output))
                }
                Err(err) => Err(err),
            }
        } else if !self.deleted(address) {
            let code = self.code(address);

            let mut runtime = evm::Runtime::new(
                Rc::new(code),
                Rc::new(input),
                transaction_context.context,
                self.config.stack_limit,
                self.config.memory_limit,
            );

            let result = self.execute(&mut runtime);

            return Ok((result?, None, runtime.machine().return_value()));
        } else {
            // Contract must be empty since it was deleted, so there are no
            // instructions to run.
            return Ok((ExitReason::Succeed(ExitSucceed::Stopped), None, vec![]));
        }
    }

    /// Perform a contract call transaction
    pub fn call_contract(
        &mut self,
        caller: H160,
        callee: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
        is_static: bool,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(is_static, gas_limit)?;

        if let Err(_) = self.mark_address_as_hot(caller) {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark caller address as hot",
            )));
        }

        if let Err(err) = self.record_base_gas_cost(false, &input) {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let result = self.execute_call(
            callee,
            value.map(|value| Transfer {
                source: caller,
                target: callee,
                value,
            }),
            input,
            TransactionContext::new(caller, callee, value.unwrap_or(U256::zero())),
        );

        self.end_initial_transaction(result)
    }

    /// Perform a create-contract transaction
    pub fn create_contract(
        &mut self,
        caller: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(false, gas_limit)?;

        if let Err(_) = self.mark_address_as_hot(caller) {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark callee address as hot",
            )));
        }

        if let Err(err) = self.record_base_gas_cost(true, &input) {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let default_create_scheme = CreateScheme::Legacy { caller };

        let result = self.execute_create(
            caller,
            default_create_scheme,
            value.unwrap_or(U256::zero()),
            input,
            false,
        );

        self.end_initial_transaction(result)
    }

    fn get_or_create_account(
        &self,
        address: H160,
    ) -> Result<EthereumAccount, EthereumError> {
        self.evm_account_storage
            .get_or_create(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    fn get_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note: if we get an error we cannot report this to SputnikVM as the return types
        // for functions that use _this_ function don't support errors. Rather than do
        // error handling in all those functions (and those we'll write in the future), we
        // do the error handling here.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Debug,
                "Failed to get account path for EVM handler get_account"
            );
            None
        }
    }

    fn get_original_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note, there is no way to recover from an error when creating the
        // account path. At this point we are being called from SputnikVM and
        // it does not allow for this to fail, so we just return None.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get_original(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Debug,
                "Failed to get account path for EVM handler get_original_account"
            );
            None
        }
    }

    pub fn increment_nonce(&mut self, address: H160) -> Result<(), EthereumError> {
        match account_path(&address) {
            Ok(path) => {
                let mut account =
                    self.evm_account_storage.get_or_create(self.host, &path)?;
                account
                    .increment_nonce(self.host)
                    .map_err(EthereumError::from)
            }
            Err(err) => {
                log!(
                    self.host,
                    Debug,
                    "Failed to increment nonce for account {:?}",
                    address
                );
                Err(EthereumError::from(AccountStorageError::from(err)))
            }
        }
    }

    fn set_contract_code(
        &mut self,
        address: H160,
        code: Vec<u8>,
    ) -> Result<(), EthereumError> {
        self.get_or_create_account(address)?
            .set_code(self.host, &code)
            .map_err(EthereumError::from)
    }

    fn get_nonce(&self, address: H160) -> U256 {
        self.get_account(address)
            .map(|account| account.nonce(self.host).unwrap_or_default())
            .unwrap_or_default()
    }

    /// Completely delete an account including nonce, code, and data. This is for
    /// contract selfdestruct completion, ie, when contract selfdestructs takes final
    /// effect.
    fn delete_contract(&mut self, address: H160) -> Result<(), EthereumError> {
        log!(self.host, Debug, "Deleting contract at {:?}", address);

        self.evm_account_storage
            .delete(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    /// Borrow a reference to the host - needed for eg precompiled contracts
    pub fn borrow_host(&mut self) -> &'_ mut Host {
        self.host
    }

    /// Begin the first transaction layer
    ///
    /// This requires that no other transaction is in progress. If there is a
    /// transaction in progress, then the function returns an error to report
    /// this.
    fn begin_initial_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();
        log!(
            self.host,
            Debug,
            "Begin initial transaction at transaction depth: {}",
            current_depth
        );

        if current_depth > 0 {
            log!(
                self.host,
                Debug,
                "Initial transaction when there is already {} transaction",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                true,
            ));
        }

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
            AccessRecord::new(),
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Final commit of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn commit_initial_transaction(
        &mut self,
        new_address: Option<H160>,
        result: Vec<u8>,
        reason: ExitReason,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();
        log!(
            self.host,
            Debug,
            "Committing initial transaction. Level is {:?}",
            current_depth
        );

        if current_depth != 1 {
            log!(
                self.host,
                Debug,
                "Committing final transaction, but there are {:?} transactions",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                false,
            ));
        }

        if current_depth != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                current_depth,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        if let Some(last_layer) = self.transaction_data.pop() {
            for address in last_layer.deleted_contracts.iter() {
                if self.delete_contract(*address).is_err() {
                    log!(
                        self.host,
                        Debug,
                        "Failed to remove deleted address {:?}",
                        address
                    );
                }
            }

            self.evm_account_storage
                .commit_transaction(self.host)
                .map_err(EthereumError::from)?;

            Ok(ExecutionOutcome {
                gas_used,
                is_success: true,
                reason,
                new_address,
                logs: last_layer.logs,
                result: Some(result),
                withdrawals: last_layer.withdrawals,
                estimated_ticks_used: self.estimated_ticks_used,
            })
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty when committing the initial transaction",
            )))
        }
    }

    /// Rollback of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn rollback_initial_transaction(
        &mut self,
        result: Option<Vec<u8>>,
        reason: ExitReason,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();
        log!(
            self.host,
            Debug,
            "Rolling back the initial transaction. Level is {:?}",
            current_depth
        );

        if current_depth != 1 {
            log!(
                self.host,
                Debug,
                "Rolling back initial transaction, but there are {:?} in progress",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                false,
            ));
        }

        if current_depth != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                current_depth,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)?;

        let _ = self.transaction_data.pop();

        Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            reason,
            new_address: None,
            logs: vec![],
            result,
            withdrawals: vec![],
            estimated_ticks_used: self.estimated_ticks_used,
        })
    }

    /// End the initial transaction with either a commit or a rollback. The
    /// outcome depends on the execution result given.
    fn end_initial_transaction(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        match execution_result {
            Ok((ExitReason::Succeed(r), new_address, result)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with success: {:?}",
                    r
                );

                self.commit_initial_transaction(
                    new_address,
                    result,
                    ExitReason::Succeed(r),
                )
            }
            Ok((ExitReason::Revert(ExitRevert::Reverted), _, result)) => self
                .rollback_initial_transaction(
                    Some(result),
                    ExitReason::Revert(ExitRevert::Reverted),
                ),
            Ok((ExitReason::Error(error), _, _)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with an error: {:?}",
                    error
                );

                self.rollback_initial_transaction(None, ExitReason::Error(error))
            }
            Ok((ExitReason::Fatal(ExitFatal::Other(cow_str)), _, _)) => {
                self.rollback_initial_transaction(
                    None,
                    ExitReason::Fatal(ExitFatal::Other(cow_str.clone())),
                )?;
                Err(EthereumError::WrappedError(cow_str))
            }
            Ok((ExitReason::Fatal(fatal_error), _, _)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with a fatal error: {:?}",
                    fatal_error
                );

                self.rollback_initial_transaction(None, ExitReason::Fatal(fatal_error))
            }
            Err(err) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with an Ethereum error: {:?}",
                    err
                );

                self.rollback_initial_transaction(
                    None,
                    ethereum_error_to_exit_reason(&err),
                )?;
                Err(err)
            }
        }
    }

    /// Begin an intermediate transaction
    fn begin_inter_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();
        log!(
            self.host,
            Debug,
            "Begin transaction from {} at transaction depth: {}",
            self.origin(),
            current_depth
        );

        let Some(current_top) = self.transaction_data.last() else {
            return Err(EthereumError::InconsistentTransactionStack(0, false, true));
        };

        let accessed_storage_keys = current_top.accessed_storage_keys.clone();

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
            accessed_storage_keys,
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Commit an intermediate transaction
    fn commit_inter_transaction(&mut self) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        if current_depth < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Commit transaction at transaction depth: {}",
            current_depth
        );

        let gas_remaining = self.gas_remaining();

        self.evm_account_storage
            .commit_transaction(self.host)
            .map_err(EthereumError::from)?;

        if let Some(mut committed_data) = self.transaction_data.pop() {
            if let Some(top_layer) = self.transaction_data.last_mut() {
                top_layer
                    .logs
                    .try_reserve_exact(committed_data.logs.len())?;
                top_layer.logs.append(&mut committed_data.logs);

                top_layer
                    .withdrawals
                    .try_reserve_exact(committed_data.withdrawals.len())?;
                top_layer
                    .withdrawals
                    .append(&mut committed_data.withdrawals);

                top_layer
                    .deleted_contracts
                    .extend(committed_data.deleted_contracts);
                top_layer.accessed_storage_keys = committed_data.accessed_storage_keys;

                self.record_stipend(gas_remaining)?;

                Ok(())
            } else {
                Err(EthereumError::InconsistentState(Cow::from(
                    "The transaction data stack is empty",
                )))
            }
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty at commit",
            )))
        }
    }

    /// Rollback an intermediate transaction
    fn rollback_inter_transaction(
        &mut self,
        refund_gas: bool,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        if current_depth < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Rollback transaction at transaction depth: {}",
            current_depth
        );

        if refund_gas {
            let gas_remaining = self.gas_remaining();
            let _ = self.transaction_data.pop();
            self.record_stipend(gas_remaining)?;
        } else {
            let _ = self.transaction_data.pop();
        }

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// End a transaction based on an execution result from a call to
    /// [execute]. This can be either a rollback or a commit depending
    /// on whether the execution was successful or not.
    ///
    /// This function applies _only_ to intermediate transactions. Calling
    /// it with only the initial transaction in progress is an error.
    fn end_inter_transaction<T>(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
    ) -> Capture<CreateOutcome, T> {
        if let Ok((ref _r @ ExitReason::Succeed(_), _, _)) = execution_result {
            log!(
                self.host,
                Debug,
                "Intermediate transaction ended with: {:?}",
                _r
            );

            if let Err(err) = self.commit_inter_transaction() {
                log!(
                    self.host,
                    Debug,
                    "Committing intermediate transaction caused an error: {:?}",
                    err
                );

                return Capture::Exit((
                    ethereum_error_to_exit_reason(&err),
                    None,
                    vec![],
                ));
            }
        } else if let Ok((ExitReason::Revert(_), _, _)) = execution_result {
            log!(self.host, Debug, "Intermediate transaction reverted");

            if let Err(err) = self.rollback_inter_transaction(true) {
                log!(
                    self.host,
                    Debug,
                    "Rolling back reverted transaction caused an error: {:?}",
                    err
                );

                return Capture::Exit((
                    ethereum_error_to_exit_reason(&err),
                    None,
                    vec![],
                ));
            }
        } else if let Ok((ExitReason::Error(_), _, _)) = execution_result {
            // Internal call failed. [rollback_inter_transaction] will consume
            // the gas with [refund_gas = false] and revert all sub-context
            // side-effect and continue the execution.

            if let Err(err) = self.rollback_inter_transaction(false) {
                log!(
                    self.host,
                    Debug,
                    "Rolling back intermediate transaction caused an error: {:?}",
                    err
                );

                return Capture::Exit((
                    ethereum_error_to_exit_reason(&err),
                    None,
                    vec![],
                ));
            }
        } else if let Err(err) = self.rollback_inter_transaction(false) {
            log!(
                self.host,
                Debug,
                "Intermediate transaction ended in error: {:?}",
                err
            );

            return Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]));
        }

        match execution_result {
            Ok(res) => Capture::Exit(res),
            Err(err) => {
                Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]))
            }
        }
    }

    fn nested_call_gas_limit(&mut self, target_gas: Option<u64>) -> Option<u64> {
        target_gas.map(|gas| {
            // Part of EIP-150: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md
            let gas_remaining = self.gas_remaining();
            let max_gas_limit = if self.config.call_l64_after_gas {
                gas_remaining - gas_remaining / 64
            } else {
                gas_remaining
            };

            min(gas, max_gas_limit)
        })
    }

    pub fn warm_access_enabled() -> bool {
        return false;
    }
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> Handler for EvmHandler<'a, Host> {
    type CreateInterrupt = Infallible;
    type CreateFeedback = Infallible;
    type CallInterrupt = Infallible;
    type CallFeedback = Infallible;

    fn balance(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.balance(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_size(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.code_size(self.host).ok())
            .unwrap_or(U256::zero())
    }

    // Hash of the chosen account's code, the empty hash (CODE_HASH_DEFAULT) if the account has no code,
    // or 0 if the account does not exist or has been destroyed.
    fn code_hash(&self, address: H160) -> H256 {
        if !self.exists(address) {
            return H256::zero();
        }

        self.get_account(address)
            .and_then(|a| a.code_hash(self.host).ok())
            .unwrap_or(CODE_HASH_DEFAULT)
    }

    fn code(&self, address: H160) -> Vec<u8> {
        // TODO: mark address as hot
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        self.get_account(address)
            .and_then(|a| a.code(self.host).ok())
            .unwrap_or_default()
    }

    fn storage(&self, address: H160, index: H256) -> H256 {
        self.get_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn original_storage(&self, address: H160, index: H256) -> H256 {
        self.get_original_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn gas_left(&self) -> U256 {
        self.gas_remaining().into()
    }

    fn gas_price(&self) -> U256 {
        self.effective_gas_price
    }

    fn origin(&self) -> H160 {
        self.origin
    }

    fn block_hash(&self, number: U256) -> H256 {
        // return 0 when block number not in valid range
        // Ref. https://www.evm.codes/#40?fork=shanghai (opcode 0x40)

        match self.block.number.checked_sub(number) {
            Some(block_diff)
                if block_diff <= U256::from(256) && block_diff != U256::zero() =>
            {
                storage::blocks::get_block_hash(self.host, number)
                    .unwrap_or_else(|_| H256::zero())
            }
            _ => H256::zero(),
        }
    }

    fn block_number(&self) -> U256 {
        self.block.number
    }

    fn block_coinbase(&self) -> H160 {
        self.block.coinbase
    }

    fn block_timestamp(&self) -> U256 {
        self.block.timestamp
    }

    fn block_difficulty(&self) -> U256 {
        // There's no difficulty in the blocks
        // A default value is returned here
        U256::zero()
    }

    fn block_gas_limit(&self) -> U256 {
        self.block.gas_limit.into()
    }

    fn block_base_fee_per_gas(&self) -> U256 {
        self.block.base_fee_per_gas()
    }

    fn block_randomness(&self) -> Option<H256> {
        None // STUB
    }

    fn chain_id(&self) -> U256 {
        self.block.chain_id
    }

    fn exists(&self, address: H160) -> bool {
        self.code_size(address) > U256::zero()
            || self.get_nonce(address) > U256::zero()
            || self.balance(address) > U256::zero()
    }

    fn deleted(&self, address: H160) -> bool {
        for data in &self.transaction_data {
            if data.deleted_contracts.contains(&address) {
                return true;
            }
        }

        false
    }

    fn is_cold(&mut self, address: H160, index: Option<H256>) -> Result<bool, ExitError> {
        if !self.enable_warm_access {
            return Ok(true);
        }

        match index {
            Some(index) => {
                let is_cold = self.is_storage_hot(address, index).map(|x| !x);
                if let Ok(true) = is_cold {
                    self.mark_storage_as_hot(address, index)?;
                }
                is_cold
            }
            None => {
                // It is possible is use the precompileset directly. However, since there are
                // still missing precompiled contract, doing so would cause regression in
                // evaluation test suite
                if BTreeSet::from([
                    H160::from_low_u64_be(1u64),
                    H160::from_low_u64_be(2u64),
                    H160::from_low_u64_be(3u64),
                    H160::from_low_u64_be(4u64),
                    H160::from_low_u64_be(5u64),
                    H160::from_low_u64_be(6u64),
                    H160::from_low_u64_be(7u64),
                    H160::from_low_u64_be(8u64),
                    H160::from_low_u64_be(9u64),
                    H160::from_str("ff00000000000000000000000000000000000001").unwrap(),
                ])
                .contains(&address)
                {
                    return Ok(false);
                }
                let is_cold = self.is_address_hot(address).map(|x| !x);
                if let Ok(true) = is_cold {
                    self.mark_address_as_hot(address)?;
                }
                is_cold
            }
        }
    }

    fn set_storage(
        &mut self,
        address: H160,
        index: H256,
        value: H256,
    ) -> Result<(), ExitError> {
        let mut account = self.get_or_create_account(address).map_err(|_| {
            ExitError::Other(Cow::from("Could not get account for set_storage"))
        })?;

        account
            .set_storage(self.host, &index, &value)
            .map_err(|_| ExitError::Other(Cow::from("Could not set_storage in handler")))
    }

    fn log(
        &mut self,
        address: H160,
        topics: Vec<H256>,
        data: Vec<u8>,
    ) -> Result<(), ExitError> {
        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.logs.push(Log {
                address,
                topics,
                data,
            });
            Ok(())
        } else {
            Err(ExitError::Other(Cow::from("No transaction data for log")))
        }
    }

    fn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {
        let balance = self.balance(address);

        self.execute_transfer(address, target, balance)
            .map_err(|err| {
                ExitError::Other(Cow::from(
                    "Could not execute transfer on contract delete",
                ))
            })?;

        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.deleted_contracts.insert(address);

            Ok(())
        } else {
            Err(ExitError::Other(Cow::from(
                "No transaction data for delete",
            )))
        }
    }

    fn create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        init_code: Vec<u8>,
        target_gas: Option<u64>,
    ) -> Capture<CreateOutcome, Self::CreateInterrupt> {
        let gas_limit = self.nested_call_gas_limit(target_gas);

        if let Err(err) = self.begin_inter_transaction(false, gas_limit) {
            log!(
                self.host,
                Debug,
                "Not enought gas for call. Required at least: {:?}",
                gas_limit
            );

            Capture::Exit((
                ExitReason::Fatal(ExitFatal::Other(Cow::from(
                    "Out of gas before recursive create",
                ))),
                None,
                vec![],
            ))
        } else {
            let result = self.execute_create(caller, scheme, value, init_code, true);

            self.end_inter_transaction(result)
        }
    }

    fn call(
        &mut self,
        code_address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        target_gas: Option<u64>,
        is_static: bool,
        context: Context,
    ) -> Capture<CallOutcome, Self::CallInterrupt> {
        let mut gas_limit = self.nested_call_gas_limit(target_gas);

        if let Err(err) = self.record_cost(gas_limit.unwrap_or(0)) {
            log!(
                self.host,
                Debug,
                "Not enought gas for call. Required at least: {:?}",
                gas_limit
            );

            return Capture::Exit((
                ExitReason::Fatal(ExitFatal::Other(Cow::from(
                    "Out of gas before recursive call",
                ))),
                vec![],
            ));
        }

        // For call with transfer value > 0, a stipend is added to the gaslimit.
        // see yellowpaper, appendix H, opcode CALL (0xf1) and CALLCODE (Oxf2)
        // Note that for other CALL* opcodes sputnik will not add a transfer at all.
        if let Some(Transfer {
            source,
            target,
            value,
        }) = transfer
        {
            if value > U256::zero() {
                gas_limit = gas_limit.map(|v| v.saturating_add(self.config.call_stipend));
            }
        };

        if let Err(err) = self.begin_inter_transaction(is_static, gas_limit) {
            return Capture::Exit((ethereum_error_to_exit_reason(&err), vec![]));
        }

        let result = self.execute_call(
            code_address,
            transfer,
            input,
            TransactionContext::from_context(context),
        );

        match self.end_inter_transaction(result) {
            Capture::Exit((reason, _, value)) => {
                log!(self.host, Debug, "Call ended with reason: {:?}", reason);
                Capture::Exit((reason, value))
            }
            Capture::Trap(x) => Capture::Trap(x),
        }
    }

    fn pre_validate(
        &mut self,
        context: &Context,
        opcode: Opcode,
        stack: &Stack,
    ) -> Result<(), ExitError> {
        if let Some(cost) = evm::gasometer::static_opcode_cost(opcode) {
            self.record_cost(cost)
        } else {
            let (cost, _target, memory_cost) = evm::gasometer::dynamic_opcode_cost(
                context.address,
                opcode,
                stack,
                self.is_static(),
                self.config,
                self,
            )?;

            self.record_dynamic_cost(cost, memory_cost)
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::account_storage::init_account_storage;
    use crate::precompiles;
    use evm::Config;
    use primitive_types::{H160, H256};
    use std::cmp::Ordering;
    use std::str::FromStr;
    use tezos_ethereum::block::BlockFees;
    use tezos_smart_rollup_mock::MockHost;

    const DUMMY_ALLOCATED_TICKS: u64 = 1_000_000;

    fn set_code<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        code: Vec<u8>,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        account.set_code(handler.borrow_host(), &code).unwrap();
    }

    fn get_balance<'a>(handler: &mut EvmHandler<'a, MockHost>, address: &H160) -> U256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.balance(handler.borrow_host()).unwrap()
    }

    fn set_balance<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        new_balance: U256,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        let old_balance = account.balance(handler.borrow_host()).unwrap();
        match old_balance.cmp(&new_balance) {
            Ordering::Greater => {
                // we require that fund removal goes fine
                assert!(
                    account
                        .balance_remove(handler.borrow_host(), old_balance - new_balance)
                        .unwrap(),
                    "Could not set balance of account"
                )
            }
            Ordering::Less => account
                .balance_add(handler.borrow_host(), new_balance - old_balance)
                .unwrap(),
            Ordering::Equal => (),
        }
    }

    fn get_durable_slot<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        index: &H256,
    ) -> H256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.get_storage(handler.borrow_host(), index).unwrap()
    }

    fn dummy_first_block() -> BlockConstants {
        let block_fees = BlockFees::new(U256::from(12345));
        BlockConstants::first_block(U256::zero(), U256::one(), block_fees)
    }

    #[test]
    fn legacy_create_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let gas_price = U256::from(21000);

        // This is a randomly generated address. It has been used for testing legacy address
        // generation with zero nonce using Ethereum. To replicate (with new address):
        // - generate a fresh Ethereum account (on Rinkeby or other test net)
        // - make sure it has eth (transfer from faucet)
        // - check nonce is zero (or bump nonce accordingly below)
        // - create a new contract. Any contract will do.
        // - check address of new contract - it is `expected_result` below.
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let result = handler.create_address(CreateScheme::Legacy { caller });

        let expected_result: H160 =
            H160::from_str("43a61f3f4c73ea0d444c5c1c1a8544067a86219b").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::zero();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("0687a12da0ffa0a64a28c9512512b8ae8870b7ea").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address_nonzero_salt() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let gas_price = U256::from(21000);

        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::from_str(
            "0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("dbd0b036a125995a83d0ab020656a8355abac612").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn origin_instruction_returns_origin_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(28349_u64);

        // We use an origin distinct from caller for testing purposes
        let origin = H160::from_low_u64_be(117_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            origin,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::ORIGIN.as_u8(), // Push the 32(!) byte origin on to stack (this is "the value")
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            32_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    H256::from(origin).0.to_vec(),
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_produces_correct_output() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(28349_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH32.as_u8(), // Push a 32 byte word onto stack (this is "the value")
            0xFF_u8,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            2_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    vec![0xFF_u8, 0x01_u8],
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_fails_beyond_max_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(2340);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let input_value = U256::from(2026_u32);
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(118);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Fatal(ExitFatal::CallErrorAsFatal(
                        ExitError::CallTooDeep,
                    )),
                    None,
                    vec![],
                );
                assert_eq!(result, expected_result);
            }
            Err(err) => {
                panic!(
                    "Expected call to fail because of call depth, but got {:?}",
                    err
                );
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_succeeds_at_maximum_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(8213);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let input_value = U256::from(1025_u32); // transaction depth for contract below is callarg - 1
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(12389);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 5);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(444);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(312);
        let input: Vec<u8> = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            46_u8,
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            1_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                let expected_in_storage = H256::from_str(
                    "000000000000000000000000000000000000000000000000000000000000002e",
                )
                .unwrap();
                assert_eq!(
                    get_durable_slot(&mut handler, &address, &H256::zero()),
                    expected_in_storage
                );
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(117);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };
        let init_code: Vec<u8> = hex::decode("608060405234801561001057600080fd5b50602a600081905550610150806100286000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea26469706673582212204d6c1853cec27824f5dbf8bcd0994714258d22fc0e0dc8a2460d87c70e3e57a564736f6c63430008120033").unwrap();

        let expected_address = handler.create_address(create_scheme);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_create(caller, create_scheme, value, init_code, false);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    Some(expected_address),
                    vec![],
                );
                assert_eq!(result, expected_result);
                assert_eq!(
                    get_durable_slot(&mut handler, &expected_address, &H256::zero()),
                    H256::from_str(
                        "000000000000000000000000000000000000000000000000000000000000002a"
                    )
                    .unwrap()
                );
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_has_return_when_revert() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(117);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };

        // The code of the contract revert with 0x18 (equivalent to 24)
        let initial_code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0x18,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::MSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0x20,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::REVERT.as_u8(),
        ];

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_create(caller, create_scheme, value, initial_code, false);

        match result {
            Ok(result) => {
                // Expecting to revert with 0x18 in the return vector
                let expected_result = (
                    ExitReason::Revert(ExitRevert::Reverted),
                    None,
                    vec![
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
                    ],
                );
                assert_eq!(result, expected_result);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_does_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(118);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(117);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address, U256::from(50_u32));
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(101_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &address), U256::from(100_u32));
                assert_eq!(get_balance(&mut handler, &caller), U256::from(1_u32));
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_fails_when_insufficient_funds_for_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Error(ExitError::OutOfFund), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &caller), U256::from(99_u32));
                assert_eq!(get_balance(&mut handler, &address), U256::zero());
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn revert_can_return_a_value() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH8.as_u8(), // push value of return data
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            Opcode::PUSH1.as_u8(), // push address of return data
            0,
            Opcode::MSTORE.as_u8(), // store return data in memory
            Opcode::PUSH1.as_u8(),  // push size of return data
            8,
            Opcode::PUSH1.as_u8(), // push offset in memory of return data
            24,
            Opcode::REVERT.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Revert(ExitRevert::Reverted),
                    None,
                    vec![0, 1, 2, 3, 4, 5, 6, 7],
                );
                assert_eq!(expected_result, result);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn return_hash_of_zero_for_unavailable_block() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let hash_of_unavailable_block = handler.block_hash(U256::zero());
        assert_eq!(H256::zero(), hash_of_unavailable_block)
    }

    #[test]
    fn transactions_fails_if_not_enough_allocated_ticks() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            10_000,
            gas_price,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler
            .begin_initial_transaction(false, Some(30000))
            .unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Err(EthereumError::OutOfTicks),
            result,
            "Contract call was expected to fail and run out of ticks: \n"
        );
    }

    #[test]
    fn store_after_offset_1024() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(), // push value 0xff
            0xff,
            Opcode::PUSH2.as_u8(), // push offset 0x401 == 1025
            0x04,
            0x01,
            Opcode::MSTORE8.as_u8(), // Store 0xff at offset 1025 in memory
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Stopped), None, vec![])),
            result,
            "Writing at offset 1025 in the memory doesn't work"
        )
    }

    #[test]
    fn dont_crash_on_blockhash_instruction() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(), // push value 0x1
            0x1,
            Opcode::PUSH1.as_u8(), // push value 0x0
            0x0,
            Opcode::MSTORE.as_u8(), // a 1 at location 0
            Opcode::PUSH4.as_u8(),  // push value 0xffffffff
            0xff,
            0xff,
            0xff,
            0xff,
            Opcode::BLOCKHASH.as_u8(),
            Opcode::PUSH1.as_u8(), // push value 0x0
            0x0,
            Opcode::MSTORE.as_u8(), // store blockhash at location 0x0
            Opcode::PUSH1.as_u8(),  // push 32
            32,
            Opcode::PUSH1.as_u8(), // push 0x0
            0x0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Ok((
                ExitReason::Succeed(ExitSucceed::Returned),
                None,
                vec![0; 32],
            )),
            result,
        )
    }

    #[test]
    fn prevent_collision_create2_selfdestruct() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();

        let config = Config::shanghai();

        let caller_address: [u8; 20] =
            hex::decode("a94f5374fce5edbc8e2a8697c15331677e6ebf0b")
                .unwrap()
                .try_into()
                .unwrap();
        let caller = H160::from(caller_address);
        let target_address: [u8; 20] =
            hex::decode("ec2c6832d00680ece8ff9254f81fdab0a5a2ac50")
                .unwrap()
                .try_into()
                .unwrap();
        let target_address = H160::from(target_address);

        let transaction_context =
            TransactionContext::new(caller, target_address, U256::zero());

        let gas_price = U256::from(21000);

        // { (CALL 50000 0xec2c6832d00680ece8ff9254f81fdab0a5a2ac50 0 0 0 0 0) (MSTORE 0 0x6460016001556000526005601bf3) (CREATE2 0 18 14 0) }
        let input = hex::decode("6000600060006000600073e2b35478fdd26477cc576dd906e6277761246a3c61c350f1506000600060006000f500").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        // { (SELFDESTRUCT 0x10) }
        let code = hex::decode("6010ff").unwrap();

        set_code(&mut handler, &target_address, code);
        set_balance(&mut handler, &caller, U256::from(1000000000000000000u64));

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(target_address, None, input, transaction_context);

        // This assertion will change with the upcoming Dencun config/fork
        // See: https://eips.ethereum.org/EIPS/eip-6780
        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Suicided), None, vec![],)),
            result,
        );

        let code = handler.code(target_address);
        let balance = handler.balance(target_address);

        assert_eq!(code, vec![96, 16, 255]);
        assert_eq!(balance, U256::zero());
    }

    #[test]
    fn create_contract_with_insufficient_funds() {
        //Init
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let caller = H160::from_str("a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            U256::one(),
        );

        set_balance(&mut handler, &caller, U256::from(10000));

        let scheme = CreateScheme::Legacy { caller };
        let code = hex::decode("600c60005566602060406000f060205260076039f3").unwrap();

        let result =
            handler.execute_create(caller, scheme, U256::from(100000), code, true);

        assert_eq!(
            result.unwrap(),
            (ExitReason::Error(ExitError::OutOfFund), None, vec![])
        );
    }

    #[test]
    fn inter_call_with_non_zero_transfer_value_gets_call_stipend() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let address_1 = H160::from_low_u64_be(210_u64);
        let address_2 = H160::from_low_u64_be(211_u64);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address_1, U256::zero());
        let transfer: Option<Transfer> = None;

        let code_1: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            100, // non-zero value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call should suceed and return 1
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(), // store 1 to Memory[0:32]
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            31,
            Opcode::RETURN.as_u8(), // return byte that contains the 1
        ];

        let code_2: Vec<u8> = vec![Opcode::TIMESTAMP.as_u8()];

        set_code(&mut handler, &address_1, code_1);
        set_code(&mut handler, &address_2, code_2);

        set_balance(&mut handler, &caller, U256::from(1000_u32));
        set_balance(&mut handler, &address_1, U256::from(1000_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address_1, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Returned), None, vec![1],)),
            result,
        )
    }

    #[test]
    fn code_hash_of_zero_for_non_existing_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
        );

        let hash = handler.code_hash(H160::from_low_u64_le(1));

        assert_eq!(H256::zero(), hash)
    }

    #[test]
    fn create_contract_with_selfdestruct_init_code() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let caller = H160::from_str("a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap();
        let withdrawal_contract =
            H160::from_str("2adc25665018aa1fe0e6bc666dac8fc2697ff9ba").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            U256::one(),
        );

        set_balance(&mut handler, &caller, U256::from(1000000000));

        let code = hex::decode("732adc25665018aa1fe0e6bc666dac8fc2697ff9baff00").unwrap(); // transfer balance to 0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba and selfdestruct

        let result = handler
            .create_contract(caller, Some(U256::one()), code, None)
            .unwrap();

        let suicided_contract = result.new_address.unwrap();

        assert_eq!(result.reason, ExitReason::Succeed(ExitSucceed::Suicided));
        assert_eq!(get_balance(&mut handler, &withdrawal_contract), U256::one());
        assert_eq!(get_balance(&mut handler, &caller), U256::from(999999999));
        assert!(!handler.exists(suicided_contract));
    }

    #[test]
    fn contract_that_selfdestruct_not_deleted_within_same_transaction() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS * 10000,
            gas_price,
        );

        let address_1 = H160::from_low_u64_be(210_u64);
        let address_2 = H160::from_low_u64_be(211_u64);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address_1, U256::zero());
        let transfer: Option<Transfer> = None;

        let code_1: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0, // value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH2.as_u8(),
            100,
            0,                    // gas
            Opcode::CALL.as_u8(), // call should cause address 2 to selfdestruct
            Opcode::POP.as_u8(),  // pop return value off the stack
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::EXTCODESIZE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(), // store 1 to Memory[0:32]
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            31,
            Opcode::RETURN.as_u8(), // return codesize of the contract that selfdestruct
        ];

        let code_2: Vec<u8> = vec![Opcode::PUSH1.as_u8(), 0, Opcode::SUICIDE.as_u8()];

        set_code(&mut handler, &address_1, code_1);
        set_code(&mut handler, &address_2, code_2);

        set_balance(&mut handler, &caller, U256::from(1000_u32));
        set_balance(&mut handler, &address_1, U256::from(1000_u32));

        handler
            .begin_initial_transaction(false, Some(1000000))
            .unwrap();

        let result =
            handler.execute_call(address_1, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Returned), None, vec![3],)),
            result,
        )
    }
}
