/******************************************************************************/
/*                                                                            */
/* MIT License                                                                */
/* Copyright (c) 2023 Serokell <hi@serokell.io>                               */
/*                                                                            */
/* Permission is hereby granted, free of charge, to any person obtaining a    */
/* copy of this software and associated documentation files (the "Software"), */
/* to deal in the Software without restriction, including without limitation  */
/* the rights to use, copy, modify, merge, publish, distribute, sublicense,   */
/* and/or sell copies of the Software, and to permit persons to whom the      */
/* Software is furnished to do so, subject to the following conditions:       */
/*                                                                            */
/* The above copyright notice and this permission notice shall be included    */
/* in all copies or substantial portions of the Software.                     */
/*                                                                            */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR */
/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   */
/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    */
/* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER */
/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    */
/* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        */
/* DEALINGS IN THE SOFTWARE.                                                  */
/*                                                                            */
/******************************************************************************/

use ascii::AsciiString;
use num_bigint::{BigInt, BigUint, Sign};
use std::str::FromStr;

use crate::ast::{Parsed, Type, Instr, UValue};

grammar;

match {
  r"(?-u:\s)+" => {}, // more or less same as default, but required to build w/o unicode
  _
}

pub NakedValue: UValue<Parsed> = {
    PrimValue => <>,
    CompValue => <>,
    "(" <NakedValue> ")" => <>,
}

pub ParValue: UValue<Parsed> = {
    PrimValue => <>,
    "(" <CompValue> ")" => <>,
    "(" <ParValue> ")" => <>,
}

pub CompValue: UValue<Parsed> = {
    r"Pair" <ParValue> <PairValArgs> => UValue::new_pair((), <>),
    r"Left" <ParValue>               => UValue::new_left((), <>),
    r"Right" <ParValue>              => UValue::new_right((), <>),
    r"Some" <ParValue>               => UValue::new_some((), <>),
    Instr                            => UValue::Instr((), <>),
}

pub PairValArgs: UValue<Parsed> = {
    ParValue => <>,
    <ParValue> <PairValArgs> => UValue::new_pair((), <>),
}

pub PrimValue: UValue<Parsed> = {
    Int                    => UValue::Int((), <>),
    r#""[^"]+""#           => UValue::String((), AsciiString::from_str(&<>[1..<>.len()-1]).unwrap()),
    r"0x([0-9a-fA-F]{2})*" => UValue::Bytes((), hex::decode(&(<>[2..])).unwrap()),
    r"Unit"                => UValue::Unit(()),
    r"True"                => UValue::True(()),
    r"False"               => UValue::False(()),
    r"None"                => UValue::None(()),
    "{" <SeqValue> "}"     => UValue::Seq((), <>),
}

pub SeqValue = Seq<NakedValue>;

pub PrimType: Type<Parsed> = {
    r"key"                        => Type::Key(()),
    r"unit"                       => Type::Unit(()),
    r"signature"                  => Type::Signature(()),
    r"chain_id"                   => Type::ChainId(()),
    r"operation"                  => Type::Operation(()),
    r"int"                        => Type::Int(()),
    r"nat"                        => Type::Nat(()),
    r"string"                     => Type::String(()),
    r"bytes"                      => Type::Bytes(()),
    r"mutez"                      => Type::Mutez(()),
    r"bool"                       => Type::Bool(()),
    r"key_hash"                   => Type::KeyHash(()),
    r"bls_12381_fr"               => Type::Bls12381Fr(()),
    r"bls_12381_g1"               => Type::Bls12381G1(()),
    r"bls_12381_g2"               => Type::Bls12381G2(()),
    r"timestamp"                  => Type::Timestamp(()),
    r"address"                    => Type::Address(()),
    r"sapling_state" <UInt>       => Type::SaplingState((), <>),
    r"sapling_transaction" <UInt> => Type::SaplingTransaction((), <>),
    r"never"                      => Type::Never(()),
}

pub CompType: Type<Parsed> = {
    r"option"   <ParType>            => Type::new_option((), <>),
    r"list"     <ParType>            => Type::new_list((), <>),
    r"set"      <ParType>            => Type::new_set((), <>),
    r"contract" <ParType>            => Type::new_contract((), <>),
    r"ticket"   <ParType>            => Type::new_ticket((), <>),
    r"pair"     <ParType> <PairArgs> => Type::new_pair((), <>),
    r"or"       <ParType> <ParType>  => Type::new_or((), <>),
    r"lambda"   <ParType> <ParType>  => Type::new_lambda((), <>),
    r"map"      <ParType> <ParType>  => Type::new_map((), <>),
    r"big_map"  <ParType> <ParType>  => Type::new_big_map((), <>),
}

pub PairArgs: Type<Parsed> = {
    ParType => <>,
    <ParType> <PairArgs> => Type::new_pair((), <>)
}

pub ParType: Type<Parsed> = {
    PrimType => <>,
    "(" <CompType> ")" => <>,
    "(" <ParType> ")" => <>,
}

pub NakedType: Type<Parsed> = {
    PrimType => <>,
    CompType => <>,
    "(" <NakedType> ")" => <>,
}

pub UInt: BigUint = {
    r"[0-9]+" => BigUint::from_str(<>).unwrap(),
}

pub Int: BigInt = {
    <Sign> <UInt> => BigInt::from_biguint(<>),
}

pub Sign: Sign = {
    "+" => Sign::Plus,
    "-" => Sign::Minus,
        => Sign::Plus,
}

pub InstrSeq = Seq<InstrNest>;

pub InstrNest: Instr<Parsed> = {
    Instr => <>,
    "{" <InstrSeq> "}" => Instr::Nest((), <>)
}

pub Instr: Instr<Parsed> = {
    "CAR"                    => Instr::Car(()),
    "CDR"                    => Instr::Cdr(()),
    "PAIR"                   => Instr::Pair(()),
    "PUSH" <ty: ParType> <v: ParValue>
                             => Instr::Push((ty, Box::new(v))),
    "NIL" <ParType>          => Instr::Nil(<>),
    "ADD"                    => Instr::Add(()),
    "DUP"                    => Instr::Dup(()),
    "DUP" <USize>            => Instr::DupN((), <>),
    "DROP"                   => Instr::Drop(()),
    "DROP" <USize>           => Instr::DropN((), <>),
    "DIP" <BIS>              => Instr::Dip((), <>),
    "DIP" <USize> <BIS>      => Instr::DipN((), <>),
    "SWAP"                   => Instr::Swap(()),
    "COMPARE"                => Instr::Compare(()),
    "PAIR" <USize>           => Instr::PairN((), <>),
    "UNPAIR"                 => Instr::Unpair(()),
    "UNPAIR" <USize>         => Instr::UnpairN((), <>),
    "DIG" <USize>            => Instr::Dig((), <>),
    "DUG" <USize>            => Instr::Dug((), <>),
    "FAILWITH"               => Instr::Failwith(()),
    "NEVER"                  => Instr::Never(()),
    "IF" <BIS> <BIS>         => Instr::If((), <>),
    "UNIT"                   => Instr::Unit(()),
    "LOOP" <BIS>             => Instr::Loop((), <>),
    "GT"                     => Instr::Gt(()),
    "LE"                     => Instr::Le(()),
    "INT"                    => Instr::Int(()),
    "MUL"                    => Instr::Mul(()),
}

BIS = "{" <InstrSeq> "}";

pub USize: usize = { UInt => <>.try_into().unwrap() }

Seq<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
