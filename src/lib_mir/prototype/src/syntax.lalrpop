//****************************************************************************//
//                                                                            //
// MIT License                                                                //
// Copyright (c) 2023 Serokell <hi@serokell.io>                               //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included    //
// in all copies or substantial portions of the Software.                     //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//****************************************************************************//

use num_bigint::{BigInt, BigUint, Sign};
use std::str::FromStr;

use crate::ast::{Parsed, Type, Instr, UValue};

grammar;

match {
  r"(?-u:\s)+" => {}, // more or less same as default, but required to build w/o unicode
  _
}

pub NakedValue: UValue<Parsed> = {
    PrimValue => <>,
    "(" <NakedValue> ")" => <>,
}

pub ParValue: UValue<Parsed> = {
    PrimValue => <>,
    "(" <ParValue> ")" => <>,
}

pub PrimValue: UValue<Parsed> = {
    Int                    => UValue::Int((), <>),
    "True"                 => UValue::True(()),
    "False"                => UValue::False(()),
}

pub SeqValue = Seq<NakedValue>;

pub PrimType: Type<Parsed> = {
    r"int"                        => Type::Int(()),
    r"nat"                        => Type::Nat(()),
    r"bool"                       => Type::Bool(()),
}

pub ParType: Type<Parsed> = {
    PrimType => <>,
    "(" <ParType> ")" => <>,
}

pub NakedType: Type<Parsed> = {
    PrimType => <>,
    "(" <NakedType> ")" => <>,
}

pub UInt: BigUint = {
    r"[0-9]+" => BigUint::from_str(<>).unwrap(),
}

pub Int: BigInt = {
    <Sign> <UInt> => BigInt::from_biguint(<>),
}

pub Sign: Sign = {
    "+" => Sign::Plus,
    "-" => Sign::Minus,
        => Sign::Plus,
}

pub InstrSeq = Seq<InstrNest>;

pub InstrNest: Instr<Parsed> = {
    Instr => <>,
    "{" <InstrSeq> "}" => Instr::Nest((), <>)
}

pub Instr: Instr<Parsed> = {
    "PUSH" <ty: ParType> <v: ParValue>
                             => Instr::Push((ty, Box::new(v))),
    "ADD"                    => Instr::Add(()),
    "DUP"                    => Instr::Dup(()),
    "DUP" <USize>            => Instr::DupN((), <>),
    "DROP"                   => Instr::Drop(()),
    "DROP" <USize>           => Instr::DropN((), <>),
    "DIP" <BIS>              => Instr::Dip((), <>),
    "DIP" <USize> <BIS>      => Instr::DipN((), <>),
    "SWAP"                   => Instr::Swap(()),
    "IF" <BIS> <BIS>         => Instr::If((), <>),
    "LOOP" <BIS>             => Instr::Loop((), <>),
    "GT"                     => Instr::Gt(()),
    "LE"                     => Instr::Le(()),
    "INT"                    => Instr::Int(()),
    "MUL"                    => Instr::Mul(()),
}

BIS = "{" <InstrSeq> "}";

pub USize: usize = { UInt => <>.try_into().unwrap() }

Seq<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
