// SPDX-FileCopyrightText: 2022-2023 TriliTech <contact@trili.tech>
// SPDX-FileCopyrightText: 2023 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Handle details of EVM runtime
//!
//! The interface between SputnikVM and the kernel. This includes interface
//! to storage, account balances, block constants, _and transaction state_.

use crate::account_storage::{
    account_path, AccountStorageError, EthereumAccount, EthereumAccountStorage,
    CODE_HASH_DEFAULT,
};
use crate::storage;
use crate::transaction::TransactionContext;
use crate::EthereumError;
use crate::PrecompileSet;
use alloc::borrow::Cow;
use alloc::rc::Rc;
use core::convert::Infallible;
use evm::executor::stack::Log;
use evm::gasometer::{GasCost, Gasometer, MemoryCost};
use evm::{
    Capture, Config, Context, CreateScheme, ExitError, ExitFatal, ExitReason, ExitRevert,
    ExitSucceed, Handler, Opcode, Stack, Transfer,
};
use host::runtime::Runtime;
use primitive_types::{H160, H256, U256};
use sha3::{Digest, Keccak256};
use std::fmt::Debug;
use tezos_ethereum::block::BlockConstants;
use tezos_ethereum::withdrawal::Withdrawal;
use tezos_evm_logging::{log, Level::*};

/// Outcome of making the [EvmHandler] run an Ethereum transaction
///
/// Be it contract -call, -create or simple transfer, the handler will update the world
/// state in durable storage _and_ produce a summary of the outcome that will be needed
/// for creating a transaction receipt.
#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// How much gas was used for processing an entire transaction.
    pub gas_used: u64,
    /// Whether the transaction succeeded or not.
    ///  - In case of transfer-, whether the funds were transferred
    ///  - In case of call-, whether toplevel call returned or stopped (success), or
    ///    something else (revert, invalid code, etc. are non-successes).
    ///  - In case of create-, whethere a new contract was created or not.
    pub is_success: bool,
    /// In case of create- transactions, this field contains address of the new contract
    pub new_address: Option<H160>,
    /// Logs generated by the transaction.
    pub logs: Vec<Log>,
    /// Result of the execution
    pub result: Option<Vec<u8>>,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
}

/// The result of calling a contract as expected by the SputnikVM EVM implementation.
/// First part of the tuple tells Sputnik how the execution went (success or failure
/// and in what way). Second part tells Sputnik the return data if any.
type CallOutcome = (ExitReason, Vec<u8>);

/// The result of creating a contract as expected by the SputnikVM EVM implementation.
/// First part of the triple is the execution outcome - same as for normal contract
/// execution. Second part is the address of the newly created contract, if one was
/// created. Last part is the return value, which is required by Sputnik, but it is
/// always an empty vector when this type is used for create outcome.
///
/// Beware that this type is sometimes used as outcome of a _call_. This is simply to
/// be able to use the `end_xxx_transaction` functions for both contract -create and
/// -call. In this case, the last element of the triple can be non-empty, and the
/// address will be `None`.
type CreateOutcome = (ExitReason, Option<H160>, Vec<u8>);

/// Wrap ethereum errors in the SputnikVM errors
///
/// This function wraps critical errors that indicate something is wrong
/// with the kernel or rollup node into errors that can be passed on to
/// SputnikVM execution. This is needed if an error occurs in a callback
/// called by SputnikVM.
fn ethereum_error_to_exit_reason(exit_reason: EthereumError) -> ExitReason {
    ExitReason::Fatal(ExitFatal::Other(Cow::from(format!("{:?}", exit_reason))))
}

/// Data related to the current transaction layer
struct TransactionLayerData<'config> {
    /// Gasometer for the current transaction layer. If this value is
    /// `None`, then the current transaction has no gas limit and no
    /// gas accounting.
    pub gasometer: Option<Gasometer<'config>>,
    /// Whether the current transaction is static or not, ie, if the
    /// transaction is allowed to update durable storage.
    pub is_static: bool,
    /// The log records gathered in this layer of transactions and any
    /// committed sub layers.
    pub logs: Vec<Log>,
    /// The addresses of contracts that have been deleted as part of
    /// the current transaction.
    pub deleted_contracts: Vec<H160>,
    /// Any withdrawals generated by the current transaction level and
    /// successful sub-levels.
    pub withdrawals: Vec<Withdrawal>,
}

impl<'config> TransactionLayerData<'config> {
    /// Create the data associated with one layer of transactions -
    /// one Ethereum transaction context. It initially has no log
    /// records. If the gas limit is `None`, then there will be no
    /// accounting for gas usage throughout the transaction, ie, there
    /// will be no gasometer.
    pub fn new(is_static: bool, gas_limit: Option<u64>, config: &'config Config) -> Self {
        TransactionLayerData {
            gasometer: gas_limit.map(|gl| Gasometer::new(gl, config)),
            is_static,
            logs: vec![],
            deleted_contracts: vec![],
            withdrawals: vec![],
        }
    }
}

/// The implementation of the SputnikVM [Handler] trait
pub struct EvmHandler<'a, Host: Runtime> {
    /// The host
    host: &'a mut Host,
    /// The ethereum accounts storage
    evm_account_storage: &'a mut EthereumAccountStorage,
    /// The original caller initiating the toplevel transaction
    origin: H160,
    /// The constants for the current block
    pub block: &'a BlockConstants,
    /// The precompiled functions
    precompiles: &'a dyn PrecompileSet<Host>,
    /// The configuration, eg, London or Frontier for execution
    config: &'a Config,
    /// The contexts associated with transaction(s) currently in
    /// progress
    transaction_data: Vec<TransactionLayerData<'a>>,
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> EvmHandler<'a, Host> {
    /// Create a new handler to suit a new, initial EVM call context
    pub fn new(
        host: &'a mut Host,
        evm_account_storage: &'a mut EthereumAccountStorage,
        origin: H160,
        block: &'a BlockConstants,
        config: &'a Config,
        precompiles: &'a dyn PrecompileSet<Host>,
    ) -> Self {
        Self {
            host,
            evm_account_storage,
            origin,
            block,
            config,
            precompiles,
            transaction_data: vec![],
        }
    }

    /// Get the total amount of gas used for the duration of the current
    /// transaction.
    pub fn gas_used(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| {
                layer
                    .gasometer
                    .as_ref()
                    .map(|g| g.total_used_gas())
                    .unwrap_or(0_u64)
            })
            .unwrap_or(0_u64)
    }

    /// Get the amount of gas still available for the current transaction.
    fn gas_remaining(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| layer.gasometer.as_ref().map(|g| g.gas()).unwrap_or(0_u64))
            .unwrap_or(0_u64)
    }

    /// Record the cost of a static-cost opcode
    pub fn record_cost(&mut self, cost: u64) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_cost(cost))
            .unwrap_or(Ok(()))
    }

    /// Record the cost of a dynamic-cost opcode
    fn record_dynamic_cost(
        &mut self,
        cost: GasCost,
        memory_cost: Option<MemoryCost>,
    ) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_dynamic_cost(cost, memory_cost))
            .unwrap_or(Ok(()))
    }

    /// Record the refund of a contract call. This differs from a storage
    /// operation refund in that the refunded gas can be used again by the
    /// same transaction. Function name reflects the SputnikVM name used to
    /// implement this functionality.
    fn record_stipend(&mut self, stipend: u64) -> Result<(), EthereumError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(EthereumError::InconsistentTransactionStack(self.transaction_data.len(), false, false))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_stipend(stipend))
            .unwrap_or(Ok(()))
            .map_err(|_| {
                EthereumError::InconsistentState(Cow::from(
                    "Recording a stipend returned an error",
                ))
            })
    }

    /// Check if an address has zero code, ie, the address is empty
    fn is_empty(&mut self, address: H160) -> Result<bool, EthereumError> {
        let Some(account) = self.get_account(address) else {
            return Ok(true);
        };

        account
            .code_size(self.borrow_host())
            .map(|s| s == U256::zero())
            .map_err(EthereumError::from)
    }

    /// Returns true if there is a static transaction in progress, otherwise
    /// return false.
    fn is_static(&self) -> bool {
        self.transaction_data
            .last()
            .map(|data| data.is_static)
            .unwrap_or(false)
    }

    /// Record the base fee part of the transaction cost. We need the SputnikVM
    /// error code in case this goes wrong, so that's what we return.
    fn record_base_gas_cost(&mut self) -> Result<(), ExitError> {
        self.record_cost(self.config.gas_transaction_call)
    }

    /// Add withdrawals to the current transaction layer
    fn add_withdrawals(
        &mut self,
        withdrawals: &mut Vec<Withdrawal>,
    ) -> Result<(), EthereumError> {
        match self.transaction_data.last_mut() {
            Some(layer) => {
                layer.withdrawals.try_reserve_exact(withdrawals.len())?;
                layer.withdrawals.append(withdrawals);

                Ok(())
            }
            None => Err(EthereumError::InconsistentTransactionStack(0, false, false)),
        }
    }

    /// Have the caller account pay for gas. Returns `Ok(true)` if the payment
    /// went through; returns `Ok(false)` if `caller` doesn't have the funds.
    /// Return `Err(...)` in case something is at fault with durable storage or
    /// runtime.
    pub fn pre_pay_transactions(
        &mut self,
        caller: H160,
        gas_limit: Option<u64>,
    ) -> Result<bool, EthereumError> {
        match gas_limit {
            Some(gas_limit) => {
                let amount = U256::from(gas_limit) * self.block.gas_price;

                log!(
                    self.host,
                    Info,
                    "{:?} pays {:?} for transaction",
                    caller,
                    amount
                );

                self.get_or_create_account(caller)?
                    .balance_remove(self.host, amount)
                    .map_err(EthereumError::from)
            }
            None => Ok(true),
        }
    }

    /// Repay unused gas
    pub fn repay_gas(
        &mut self,
        caller: H160,
        unused_gas: Option<u64>,
    ) -> Result<(), EthereumError> {
        match unused_gas {
            Some(unused_gas) => {
                let amount = U256::from(unused_gas) * self.block.gas_price;

                log!(
                    self.host,
                    Info,
                    "{:?} refunded {:?} for transaction",
                    caller,
                    amount
                );

                self.get_or_create_account(caller)?
                    .balance_add(self.host, amount)
                    .map_err(EthereumError::from)
            }
            None => Ok(()),
        }
    }

    /// Execute a SputnikVM runtime with this handler
    fn execute(
        &mut self,
        runtime: &mut evm::Runtime,
    ) -> Result<ExitReason, EthereumError> {
        match runtime.run(self) {
            Capture::Exit(reason) => Ok(reason),
            Capture::Trap(_) => Err(EthereumError::InternalTrapError),
        }
    }

    fn create_address(&mut self, scheme: CreateScheme) -> H160 {
        match scheme {
            CreateScheme::Create2 {
                caller,
                code_hash,
                salt,
            } => {
                let mut hasher = Keccak256::new();
                hasher.update([0xff]);
                hasher.update(caller);
                hasher.update(salt);
                hasher.update(code_hash);
                H256::from_slice(hasher.finalize().as_slice()).into()
            }
            CreateScheme::Legacy { caller } => {
                let nonce = self.get_nonce(caller).unwrap_or(U256::zero());
                let mut stream = rlp::RlpStream::new_list(2);
                stream.append(&caller);
                stream.append(&nonce);
                H256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()
            }
            CreateScheme::Fixed(address) => address,
        }
    }

    /// Execute a transfer between two accounts
    ///
    /// In case the transfer succeeds, the function returns
    /// `Ok(ExitReason::Succeed(ExitSucceed::Returned))`. In case the
    /// transaction fails, but execution doesn't encounter non-contract or
    /// -account errors, it returns `Ok(ExitReason::Error(err))`, where `err`
    /// indicates what went wrong (insufficient balance, etc.). In case of
    /// critical errors in the rollup node or kernel, an `Err(err)` is returned,
    /// where `err` indicates what went wrong, eg, a storage error.
    fn execute_transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
    ) -> Result<ExitReason, EthereumError> {
        log!(self.host, Info, "Executing a transfer");

        // TODO let transfers cost gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5118

        if value == U256::zero() {
            // Nothing to transfer so succeeds by default
            Ok(ExitReason::Succeed(ExitSucceed::Returned))
        } else if let Some(mut from_account) = self.get_account(from) {
            let mut to_account = self.get_or_create_account(to)?;

            if from_account.balance_remove(self.host, value)? {
                to_account
                    .balance_add(self.host, value)
                    .map_err(EthereumError::from)?;
                Ok(ExitReason::Succeed(ExitSucceed::Returned))
            } else {
                log!(
                    self.host,
                    Info,
                    "Transaction failure - balance underflow on account {:?} - withdraw {:?}",
                    from_account,
                    value
                );

                Ok(ExitReason::Fatal(ExitFatal::CallErrorAsFatal(
                    ExitError::OutOfFund,
                )))
            }
        } else {
            log!(self.host, Info, "'from' account {:?} is empty", from);
            // Accounts of zero balance by default, so this must be
            // an underflow.
            Ok(ExitReason::Error(ExitError::OutOfFund))
        }
    }

    /// Create a contract
    ///
    /// Performs the actual contract creation for both transactions initiated
    /// by external accounts and contract creation initiated through contract
    /// execution.
    ///
    /// In the specific case where this function is called via the CREATE opcode,
    /// it needs to bump the nonce. If it's a transaction initated by external
    /// accounts, the nonce must be bumped by the caller.
    fn execute_create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        initial_code: Vec<u8>,
        create_opcode: bool,
    ) -> Result<CreateOutcome, EthereumError> {
        log!(self.host, Info, "Executing a contract create");

        let address = self.create_address(scheme);

        // TODO: mark `caller` and `address` as hot for gas calculation
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        if self.evm_account_storage.stack_depth() >= self.config.stack_limit {
            return Ok((
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::CallTooDeep)),
                None,
                vec![],
            ));
        }

        let context = Context {
            address,
            caller,
            apparent_value: value,
        };

        if !self.is_empty(address)? {
            return Ok((ExitReason::Error(ExitError::CreateCollision), None, vec![]));
        }

        if let Err(error) = self.execute_transfer(caller, address, value) {
            log!(
                self.host,
                Info,
                "Failed transfer for create, funds: {:?}, from: {:?}, to: {:?}",
                value,
                caller,
                address
            );
            return Err(error);
        }

        if create_opcode {
            self.increment_nonce(caller)?
        };

        let mut runtime = evm::Runtime::new(
            Rc::new(initial_code),
            Rc::new(Vec::new()),
            context,
            self.config.stack_limit,
            self.config.memory_limit,
        );

        let result = self.execute(&mut runtime);

        // FIXME should only be succeed with return value
        // issue: https://gitlab.com/tezos/tezos/-/issues/4869
        if let Ok(ExitReason::Succeed(_)) = result {
            let code_out = runtime.machine().return_value();

            if self.deleted(address) {
                // The contract has been deleted, so the address is empty. However, after
                // creating the new contract, the _new_ contract isn't deleted.
                self.unmark_deletion(address);
            }

            self.set_contract_code(address, code_out)?;
        }

        Ok((result?, Some(address), vec![]))
    }

    /// Call a contract
    ///
    /// Perform the actual contract execution - works both for executing an
    /// Ethereum transaction as initiated by an external account or as aresult
    /// of any of the -CALL instructions.
    ///
    /// The outcome is encoded as a SputnikVM _Create_ outcome for easy transaction
    /// handling. The new address "field" in the triple is always `None`.
    #[allow(clippy::too_many_arguments)]
    fn execute_call(
        &mut self,
        address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        transaction_context: TransactionContext,
    ) -> Result<CreateOutcome, EthereumError> {
        log!(
            self.host,
            Info,
            "Executing contract call at depth: {}",
            self.evm_account_storage.stack_depth()
        );

        if self.evm_account_storage.stack_depth() > self.config.stack_limit {
            log!(self.host, Info, "Execution beyond the call limit of 1024");

            return Ok((
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::CallTooDeep)),
                None,
                vec![],
            ));
        }

        // TODO: check gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5120

        // TODO: add transfer to gas (if it is there)
        // issue: https://gitlab.com/tezos/tezos/-/issues/5121

        // TODO: touch address - mark as hot for gas calculation
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        if let Some(ref transfer) = transfer {
            match self.execute_transfer(
                transaction_context.context.caller,
                address,
                transfer.value,
            )? {
                r @ ExitReason::Fatal(_) => {
                    return Ok((r, None, vec![]));
                }
                r @ ExitReason::Error(_) => {
                    return Ok((r, None, vec![]));
                }
                r @ ExitReason::Revert(_) => {
                    // A transfer cannot revert - this implies internal error in
                    // EVM execution
                    return Err(EthereumError::InconsistentState(Cow::from(
                        "Transfer returned revert",
                    )));
                }
                ExitReason::Succeed(_) => {
                    // Otherwise result is ok and we do nothing and continue
                }
            }
        }

        if let Some(precompile_result) = self.precompiles.execute(
            self,
            address,
            &input,
            &transaction_context.context,
            self.is_static(),
            transfer,
        ) {
            match precompile_result {
                Ok(mut outcome) => {
                    self.add_withdrawals(&mut outcome.withdrawals)?;

                    Ok((outcome.exit_status, None, outcome.output))
                }
                Err(err) => Err(err),
            }
        } else if !self.deleted(address) {
            let code = self.code(address);

            let mut runtime = evm::Runtime::new(
                Rc::new(code),
                Rc::new(input),
                transaction_context.context,
                1024_usize,
                1024_usize, // TODO this is the memory limit - adjust to standard
            );

            let result = self.execute(&mut runtime);

            return Ok((result?, None, runtime.machine().return_value()));
        } else {
            // Contract must be empty since it was deleted, so there are no
            // instructions to run.
            return Ok((ExitReason::Succeed(ExitSucceed::Stopped), None, vec![]));
        }
    }

    /// Perform a contract call transaction
    pub fn call_contract(
        &mut self,
        caller: H160,
        callee: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
        is_static: bool,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(is_static, gas_limit)?;

        if let Err(err) = self.record_base_gas_cost() {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let result = self.execute_call(
            callee,
            value.map(|value| Transfer {
                source: caller,
                target: callee,
                value,
            }),
            input,
            TransactionContext::new(caller, callee, value.unwrap_or(U256::zero())),
        );

        self.end_initial_transaction(result)
    }

    /// Perform a create-contract transaction
    pub fn create_contract(
        &mut self,
        caller: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(false, gas_limit)?;

        if let Err(err) = self.record_base_gas_cost() {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let default_create_scheme = CreateScheme::Legacy { caller };

        let result = self.execute_create(
            caller,
            default_create_scheme,
            value.unwrap_or(U256::zero()),
            input,
            false,
        );

        self.end_initial_transaction(result)
    }

    /// Perform a transfer transaction
    pub fn transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(false, gas_limit)?;

        if let Err(err) = self.record_base_gas_cost() {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let result = self.execute_transfer(from, to, value)?;

        self.end_initial_transaction(Ok((result, None, vec![])))
    }

    fn get_or_create_account(
        &self,
        address: H160,
    ) -> Result<EthereumAccount, EthereumError> {
        self.evm_account_storage
            .get_or_create(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    fn get_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note: if we get an error we cannot report this to SputnikVM as the return types
        // for functions that use _this_ function don't support errors. Rather than do
        // error handling in all those functions (and those we'll write in the future), we
        // do the error handling here.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Debug,
                "Failed to get account path for EVM handler get_account"
            );
            None
        }
    }

    fn get_original_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note, there is no way to recover from an error when creating the
        // account path. At this point we are being called from SputnikVM and
        // it does not allow for this to fail, so we just return None.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get_original(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Info,
                "Failed to get account path for EVM handler get_original_account"
            );
            None
        }
    }

    pub fn increment_nonce(&mut self, address: H160) -> Result<(), EthereumError> {
        match account_path(&address) {
            Ok(path) => {
                let mut account =
                    self.evm_account_storage.get_or_create(self.host, &path)?;
                account
                    .increment_nonce(self.host)
                    .map_err(EthereumError::from)
            }
            Err(err) => {
                log!(
                    self.host,
                    Info,
                    "Failed to increment nonce for account {:?}",
                    address
                );
                Err(EthereumError::from(AccountStorageError::from(err)))
            }
        }
    }

    fn set_contract_code(
        &mut self,
        address: H160,
        code: Vec<u8>,
    ) -> Result<(), EthereumError> {
        self.get_or_create_account(address)?
            .set_code(self.host, &code)
            .map_err(EthereumError::from)
    }

    fn get_nonce(&self, address: H160) -> Result<U256, EthereumError> {
        self.get_account(address)
            .map(|account| account.nonce(self.host).map_err(EthereumError::from))
            .unwrap_or(Ok(U256::zero()))
    }

    /// If a contract has been marked for deletion, and another contract is
    /// created in its place, we need to unmark it, so that we don't delete the
    /// new contract when we finalize the effects of the transactions.
    fn unmark_deletion(&mut self, address: H160) {
        for data in &mut self.transaction_data {
            data.deleted_contracts.retain(|a| *a != address);
        }
    }

    /// Completely delete an account including nonce, code, and data. This is for
    /// contract selfdestruct completion, ie, when contract selfdestructs takes final
    /// effect.
    fn delete_contract(&mut self, address: H160) -> Result<(), EthereumError> {
        log!(self.host, Info, "Deleting contract at {:?}", address);

        self.evm_account_storage
            .delete(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    /// Borrow a reference to the host - needed for eg precompiled contracts
    pub fn borrow_host(&mut self) -> &'_ mut Host {
        self.host
    }

    /// Begin the first transaction layer
    ///
    /// This requires that no other transaction is in progress. If there is a
    /// transaction in progress, then the function returns an error to report
    /// this.
    fn begin_initial_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        log!(
            self.host,
            Debug,
            "Begin initial transaction at transaction depth: {}",
            current_depth
        );

        if current_depth > 0 {
            log!(
                self.host,
                Debug,
                "Initial transaction when there is already {} transaction",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                true,
            ));
        }

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Final commit of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn commit_initial_transaction(
        &mut self,
        new_address: Option<H160>,
        result: Vec<u8>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        log!(
            self.host,
            Debug,
            "Committing initial transaction. Level is {:?}",
            current_depth
        );

        if current_depth != 1 {
            log!(
                self.host,
                Debug,
                "Committing final transaction, but there are {:?} transactions",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                false,
            ));
        }

        if current_depth != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                current_depth,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        if let Some(last_layer) = self.transaction_data.pop() {
            self.evm_account_storage
                .commit_transaction(self.host)
                .map_err(EthereumError::from)?;

            Ok(ExecutionOutcome {
                gas_used,
                is_success: true,
                new_address,
                logs: last_layer.logs,
                result: Some(result),
                withdrawals: last_layer.withdrawals,
            })
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty when committing the initial transaction"
            )))
        }
    }

    /// Rollback of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn rollback_initial_transaction(
        &mut self,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        log!(
            self.host,
            Debug,
            "Rolling back the initial transaction. Level is {:?}",
            current_depth
        );

        if current_depth != 1 {
            log!(
                self.host,
                Debug,
                "Rolling back initial transaction, but there are {:?} in progress",
                current_depth
            );

            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                true,
                false,
            ));
        }

        if current_depth != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                current_depth,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)?;

        let _ = self.transaction_data.pop();

        Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            new_address: None,
            logs: vec![],
            result: None,
            withdrawals: vec![],
        })
    }

    /// End the initial transaction with either a commit or a rollback. The
    /// outcome depends on the execution result given.
    fn end_initial_transaction(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        match execution_result {
            Ok((ExitReason::Succeed(r), new_address, result)) => {
                log!(
                    self.host,
                    Info,
                    "The initial transaction ended with success: {:?}",
                    r
                );

                self.commit_initial_transaction(new_address, result)
            }
            Ok((ExitReason::Revert(ExitRevert::Reverted), _, _)) => {
                self.rollback_initial_transaction()
            }
            Ok((ExitReason::Error(error), _, _)) => {
                log!(
                    self.host,
                    Info,
                    "The initial transaction ended with an error: {:?}",
                    error
                );

                self.rollback_initial_transaction()
            }
            Ok((ExitReason::Fatal(ExitFatal::Other(cow_str)), _, _)) => {
                self.rollback_initial_transaction()?;
                Err(EthereumError::WrappedError(cow_str))
            }
            Ok((ExitReason::Fatal(fatal_error), _, _)) => {
                log!(
                    self.host,
                    Info,
                    "The initial transaction ended with a fatal error: {:?}",
                    fatal_error
                );

                self.rollback_initial_transaction()
            }
            Err(err) => {
                log!(
                    self.host,
                    Info,
                    "The initial transaction ended with an Ethereum error: {:?}",
                    err
                );

                self.rollback_initial_transaction()?;
                Err(err)
            }
        }
    }

    /// Begin an intermediate transaction
    fn begin_inter_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        log!(
            self.host,
            Debug,
            "Begin transaction at transaction depth: {}",
            current_depth
        );

        if current_depth == 0 {
            return Err(EthereumError::InconsistentTransactionStack(0, false, true));
        }

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Commit an intermediate transaction
    fn commit_inter_transaction(&mut self) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        if current_depth < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Commit transaction at transaction depth: {}",
            current_depth
        );

        let gas_remaining = self.gas_remaining();

        self.evm_account_storage
            .commit_transaction(self.host)
            .map_err(EthereumError::from)?;

        if let Some(mut committed_data) = self.transaction_data.pop() {
            if let Some(top_layer) = self.transaction_data.last_mut() {
                top_layer
                    .logs
                    .try_reserve_exact(committed_data.logs.len())?;
                top_layer.logs.append(&mut committed_data.logs);

                top_layer
                    .withdrawals
                    .try_reserve_exact(committed_data.withdrawals.len())?;
                top_layer
                    .withdrawals
                    .append(&mut committed_data.withdrawals);

                top_layer
                    .deleted_contracts
                    .reserve(committed_data.deleted_contracts.len());
                top_layer
                    .deleted_contracts
                    .append(&mut committed_data.deleted_contracts);

                self.record_stipend(gas_remaining)?;

                Ok(())
            } else {
                Err(EthereumError::InconsistentState(Cow::from(
                    "The transaction data stack is empty",
                )))
            }
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty at commit",
            )))
        }
    }

    /// Rollback an intermediate transaction
    fn rollback_inter_transaction(
        &mut self,
        refund_gas: bool,
    ) -> Result<(), EthereumError> {
        let current_depth = self.evm_account_storage.stack_depth();

        if current_depth < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                current_depth,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Rollback transaction at transaction depth: {}",
            current_depth
        );

        if refund_gas {
            let gas_remaining = self.gas_remaining();
            let _ = self.transaction_data.pop();
            self.record_stipend(gas_remaining)?;
        } else {
            let _ = self.transaction_data.pop();
        }

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// End a transaction based on an execution result from a call to
    /// [execute]. This can be either a rollback or a commit depending
    /// on whether the execution was successful or not.
    ///
    /// This function applies _only_ to intermediate transactions. Calling
    /// it with only the initial transaction in progress is an error.
    fn end_inter_transaction<T>(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
        promote_error: bool,
    ) -> Capture<CreateOutcome, T> {
        if let Ok((ref r @ ExitReason::Succeed(_), _, _)) = execution_result {
            log!(
                self.host,
                Info,
                "Intermediate transaction ended with: {:?}",
                r
            );

            if let Err(err) = self.commit_inter_transaction() {
                log!(
                    self.host,
                    Info,
                    "Committing intermediate transaction caused an error: {:?}",
                    err
                );

                return Capture::Exit((ethereum_error_to_exit_reason(err), None, vec![]));
            }
        } else if let Ok((ExitReason::Revert(_), _, _)) = execution_result {
            log!(self.host, Info, "Intermediate transaction reverted");

            if let Err(err) = self.rollback_inter_transaction(true) {
                log!(
                    self.host,
                    Debug,
                    "Rolling back reverted transaction caused an error: {:?}",
                    err
                );

                return Capture::Exit((ethereum_error_to_exit_reason(err), None, vec![]));
            }
        } else if let Err(err) = self.rollback_inter_transaction(false) {
            log!(
                self.host,
                Debug,
                "Intermediate transaction ended in error: {:?}",
                err
            );

            return Capture::Exit((ethereum_error_to_exit_reason(err), None, vec![]));
        }

        match execution_result {
            Ok((ExitReason::Error(err), _, _)) => {
                if promote_error {
                    Capture::Exit((
                        ExitReason::Fatal(ExitFatal::CallErrorAsFatal(err)),
                        None,
                        vec![],
                    ))
                } else {
                    Capture::Exit((ExitReason::Error(err), None, vec![]))
                }
            }
            Ok(res) => Capture::Exit(res),
            Err(err) => Capture::Exit((ethereum_error_to_exit_reason(err), None, vec![])),
        }
    }
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> Handler for EvmHandler<'a, Host> {
    type CreateInterrupt = Infallible;
    type CreateFeedback = Infallible;
    type CallInterrupt = Infallible;
    type CallFeedback = Infallible;

    fn balance(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.balance(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_size(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.code_size(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_hash(&self, address: H160) -> H256 {
        self.get_account(address)
            .and_then(|a| a.code_hash(self.host).ok())
            .unwrap_or(CODE_HASH_DEFAULT)
    }

    fn code(&self, address: H160) -> Vec<u8> {
        // TODO: mark address as hot
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        self.get_account(address)
            .and_then(|a| a.code(self.host).ok())
            .unwrap_or_default()
    }

    fn storage(&self, address: H160, index: H256) -> H256 {
        self.get_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn original_storage(&self, address: H160, index: H256) -> H256 {
        self.get_original_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn gas_left(&self) -> U256 {
        self.gas_remaining().into()
    }

    fn gas_price(&self) -> U256 {
        self.block.gas_price
    }

    fn origin(&self) -> H160 {
        self.origin
    }

    fn block_hash(&self, number: U256) -> H256 {
        // return 0 when block number not in valid range
        // Ref. https://www.evm.codes/#40?fork=shanghai (opcode 0x40)

        if self.block.number - number > U256::from(256) {
            return H256::zero();
        }
        storage::blocks::get_block_hash(self.host, number)
            .unwrap_or_else(|_| H256::zero())
    }

    fn block_number(&self) -> U256 {
        self.block.number
    }

    fn block_coinbase(&self) -> H160 {
        self.block.coinbase
    }

    fn block_timestamp(&self) -> U256 {
        self.block.timestamp
    }

    fn block_difficulty(&self) -> U256 {
        self.block.difficulty
    }

    fn block_gas_limit(&self) -> U256 {
        self.block.gas_limit.into()
    }

    fn block_base_fee_per_gas(&self) -> U256 {
        self.block.base_fee_per_gas
    }

    fn block_randomness(&self) -> Option<H256> {
        None // STUB
    }

    fn chain_id(&self) -> U256 {
        self.block.chain_id
    }

    fn exists(&self, address: H160) -> bool {
        self.code_size(address) > U256::zero()
    }

    fn deleted(&self, address: H160) -> bool {
        for data in &self.transaction_data {
            if data.deleted_contracts.contains(&address) {
                return true;
            }
        }

        false
    }

    fn is_cold(&mut self, address: H160, index: Option<H256>) -> Result<bool, ExitError> {
        // TODO: https://gitlab.com/tezos/tezos/-/issues/4866
        Ok(false) // STUB until issue above has been fixed
    }

    fn set_storage(
        &mut self,
        address: H160,
        index: H256,
        value: H256,
    ) -> Result<(), ExitError> {
        let mut account = self.get_or_create_account(address).map_err(|_| {
            ExitError::Other(Cow::from("Could not get account for set_storage"))
        })?;
        account
            .set_storage(self.host, &index, &value)
            .map_err(|_| ExitError::Other(Cow::from("Could not set_storage in handler")))
    }

    fn log(
        &mut self,
        address: H160,
        topics: Vec<H256>,
        data: Vec<u8>,
    ) -> Result<(), ExitError> {
        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.logs.push(Log {
                address,
                topics,
                data,
            });
            Ok(())
        } else {
            Err(ExitError::Other(Cow::from("No transaction data for log")))
        }
    }

    fn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {
        let balance = self.balance(address);

        self.execute_transfer(address, target, balance)
            .map_err(|err| {
                ExitError::Other(Cow::from(
                    "Could not execute transfer on contract delete",
                ))
            })?;

        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.deleted_contracts.push(address);

            if self.delete_contract(address).is_err() {
                Err(ExitError::Other(Cow::from("Failed to delete contract")))
            } else {
                Ok(())
            }
        } else {
            Err(ExitError::Other(Cow::from(
                "No transaction data for delete",
            )))
        }
    }

    fn create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        init_code: Vec<u8>,
        target_gas: Option<u64>,
    ) -> Capture<CreateOutcome, Self::CreateInterrupt> {
        if let Err(err) = self.begin_inter_transaction(false, target_gas) {
            Capture::Exit((
                ExitReason::Fatal(ExitFatal::Other(Cow::from(format!("{err:?}")))),
                None,
                vec![],
            ))
        } else {
            let result = self.execute_create(caller, scheme, value, init_code, true);

            self.end_inter_transaction(result, false)
        }
    }

    fn call(
        &mut self,
        code_address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        target_gas: Option<u64>,
        is_static: bool,
        context: Context,
    ) -> Capture<CallOutcome, Self::CallInterrupt> {
        if let Err(err) = self.record_cost(target_gas.unwrap_or(0)) {
            log!(
                self.host,
                Debug,
                "Not enought gas for call. Required at least: {:?}",
                target_gas
            );

            return Capture::Exit((
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::OutOfGas)),
                vec![],
            ));
        }

        if let Err(err) = self.begin_inter_transaction(is_static, target_gas) {
            return Capture::Exit((ethereum_error_to_exit_reason(err), vec![]));
        }

        let result = self.execute_call(
            code_address,
            transfer,
            input,
            TransactionContext::from_context(context),
        );

        match self.end_inter_transaction(result, true) {
            Capture::Exit((reason, _, value)) => {
                log!(self.host, Info, "Call ended with reason: {:?}", reason);
                Capture::Exit((reason, value))
            }
            Capture::Trap(x) => Capture::Trap(x),
        }
    }

    fn pre_validate(
        &mut self,
        context: &Context,
        opcode: Opcode,
        stack: &Stack,
    ) -> Result<(), ExitError> {
        if let Some(cost) = evm::gasometer::static_opcode_cost(opcode) {
            self.record_cost(cost)
        } else {
            let (cost, _target, memory_cost) = evm::gasometer::dynamic_opcode_cost(
                context.address,
                opcode,
                stack,
                self.is_static(),
                self.config,
                self,
            )?;

            self.record_dynamic_cost(cost, memory_cost)
        }
    }

    fn create_feedback(
        &mut self,
        _feedback: Self::CreateFeedback,
    ) -> Result<(), ExitError> {
        // TODO: issue: https://gitlab.com/tezos/tezos/-/issues/4872
        Ok(()) // this is a stub
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::account_storage::init_account_storage;
    use crate::precompiles;
    use evm::Config;
    use primitive_types::{H160, H256};
    use std::cmp::Ordering;
    use std::str::FromStr;
    use tezos_smart_rollup_mock::MockHost;

    fn set_code<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        code: Vec<u8>,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        account.set_code(handler.borrow_host(), &code).unwrap();
    }

    fn get_balance<'a>(handler: &mut EvmHandler<'a, MockHost>, address: &H160) -> U256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.balance(handler.borrow_host()).unwrap()
    }

    fn set_balance<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        new_balance: U256,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        let old_balance = account.balance(handler.borrow_host()).unwrap();
        match old_balance.cmp(&new_balance) {
            Ordering::Greater => {
                // we require that fund removal goes fine
                assert!(
                    account
                        .balance_remove(handler.borrow_host(), old_balance - new_balance)
                        .unwrap(),
                    "Could not set balance of account"
                )
            }
            Ordering::Less => account
                .balance_add(handler.borrow_host(), new_balance - old_balance)
                .unwrap(),
            Ordering::Equal => (),
        }
    }

    fn get_durable_slot<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        index: &H256,
    ) -> H256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.get_storage(handler.borrow_host(), index).unwrap()
    }

    fn dummy_first_block() -> BlockConstants {
        BlockConstants::first_block(U256::zero(), U256::one(), U256::from(21000))
    }

    #[test]
    fn legacy_create_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();

        // This is a randomly generated address. It has been used for testing legacy address
        // generation with zero nonce using Ethereum. To replicate (with new address):
        // - generate a fresh Ethereum account (on Rinkeby or other test net)
        // - make sure it has eth (transfer from faucet)
        // - check nonce is zero (or bump nonce accordingly below)
        // - create a new contract. Any contract will do.
        // - check address of new contract - it is `expected_result` below.
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let result = handler.create_address(CreateScheme::Legacy { caller });

        let expected_result: H160 =
            H160::from_str("43a61f3f4c73ea0d444c5c1c1a8544067a86219b").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::zero();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("0687a12da0ffa0a64a28c9512512b8ae8870b7ea").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address_nonzero_salt() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::from_str(
            "0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("dbd0b036a125995a83d0ab020656a8355abac612").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn origin_instruction_returns_origin_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(28349_u64);

        // We use an origin distinct from caller for testing purposes
        let origin = H160::from_low_u64_be(117_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            origin,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::ORIGIN.as_u8(), // Push the 32(!) byte origin on to stack (this is "the value")
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            32_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    H256::from(origin).0.to_vec(),
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_produces_correct_output() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(28349_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH32.as_u8(), // Push a 32 byte word onto stack (this is "the value")
            0xFF_u8,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            2_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    vec![0xFF_u8, 0x01_u8],
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_fails_beyond_max_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(2340);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let input_value = U256::from(2026_u32);
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(118);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Fatal(ExitFatal::CallErrorAsFatal(
                        ExitError::CallTooDeep,
                    )),
                    None,
                    vec![],
                );
                assert_eq!(result, expected_result);
            }
            Err(err) => {
                panic!(
                    "Expected call to fail because of call depth, but got {:?}",
                    err
                );
            }
        }
    }

    // This test will fail because it blows the stack with the Rust default
    // stack size. This could be indication that we should do issue
    // https://gitlab.com/tezos/tezos/-/issues/4888
    // use RUST_MIN_STACK=<value> cargo test -p evm-kernel --features testing
    // with <value> set to 104857600 or something similar in size
    #[ignore]
    #[test]
    fn contract_call_succeeds_at_maximum_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(8213);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let input_value = U256::from(1025_u32); // transaction depth for contract below is callarg - 1
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(12389);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 5);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(444);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(312);
        let input: Vec<u8> = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            46_u8,
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            1_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                let expected_in_storage = H256::from_str(
                    "000000000000000000000000000000000000000000000000000000000000002e",
                )
                .unwrap();
                assert_eq!(
                    get_durable_slot(&mut handler, &address, &H256::zero()),
                    expected_in_storage
                );
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(117);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };
        let init_code: Vec<u8> = hex::decode("608060405234801561001057600080fd5b50602a600081905550610150806100286000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea26469706673582212204d6c1853cec27824f5dbf8bcd0994714258d22fc0e0dc8a2460d87c70e3e57a564736f6c63430008120033").unwrap();

        let expected_address = handler.create_address(create_scheme);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_create(caller, create_scheme, value, init_code, false);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    Some(expected_address),
                    vec![],
                );
                assert_eq!(result, expected_result);
                assert_eq!(get_durable_slot(&mut handler, &expected_address, &H256::zero()), H256::from_str("000000000000000000000000000000000000000000000000000000000000002a").unwrap());
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_does_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(118);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(117);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address, U256::from(50_u32));
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(101_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &address), U256::from(100_u32));
                assert_eq!(get_balance(&mut handler, &caller), U256::from(1_u32));
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_fails_when_insufficient_funds_for_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(523_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Fatal(ExitFatal::CallErrorAsFatal(ExitError::OutOfFund)),
                    None,
                    vec![],
                );
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &caller), U256::from(99_u32));
                assert_eq!(get_balance(&mut handler, &address), U256::zero());
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn revert_can_return_a_value() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(523_u64);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH8.as_u8(), // push value of return data
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            Opcode::PUSH1.as_u8(), // push address of return data
            0,
            Opcode::MSTORE.as_u8(), // store return data in memory
            Opcode::PUSH1.as_u8(),  // push size of return data
            8,
            Opcode::PUSH1.as_u8(), // push offset in memory of return data
            24,
            Opcode::REVERT.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Revert(ExitRevert::Reverted),
                    None,
                    vec![0, 1, 2, 3, 4, 5, 6, 7],
                );
                assert_eq!(expected_result, result);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn return_hash_of_zero_for_unavailable_block() {
        let mut mock_runtime = MockHost::default();
        let block =
            BlockConstants::first_block(U256::zero(), U256::one(), U256::from(21000));
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(523_u64);

        let handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
        );

        let hash_of_unavailable_block = handler.block_hash(U256::zero());
        assert_eq!(H256::zero(), hash_of_unavailable_block)
    }
}
